{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"theroyakash algorithms Materials for FAANG and top startup coding interview and running notes on that. Made by @theroyakash Who am I? I go by theroyakash on the internet. I am a computer scientist currently doing masters in computer science from IIT (Indian Institute of Technology), with research in high performance algorithms, data structures, distributed systems, and beyond. See my work searching google for theroyakash and on Github . What is this? This material categorizes coding interview problems into a set of 8 patterns . Each pattern will be a complete tool - consisting of data structures, algorithms, and analysis techniques - to solve a specific category of problems. The goal is to build an understanding of the underlying pattern so that we can apply that pattern to solve other problems. Complete guide and roadmap for SDE I Patterns Sliding Window Pattern Arrays and Strings Linked lists Stacks and Queues Trees and Graphs along with heaps Bit Manipulation (With C/C++) Sorting and Searching Dynamic Programming with Top Down (Recursive) approach This is me! Other links Visit my website here . My Github , More about me , Send me an email .","title":"Introduction"},{"location":"#theroyakash-algorithms","text":"Materials for FAANG and top startup coding interview and running notes on that. Made by @theroyakash Who am I? I go by theroyakash on the internet. I am a computer scientist currently doing masters in computer science from IIT (Indian Institute of Technology), with research in high performance algorithms, data structures, distributed systems, and beyond. See my work searching google for theroyakash and on Github .","title":"theroyakash algorithms"},{"location":"#what-is-this","text":"This material categorizes coding interview problems into a set of 8 patterns . Each pattern will be a complete tool - consisting of data structures, algorithms, and analysis techniques - to solve a specific category of problems. The goal is to build an understanding of the underlying pattern so that we can apply that pattern to solve other problems. Complete guide and roadmap for SDE I","title":"What is this?"},{"location":"#patterns","text":"Sliding Window Pattern Arrays and Strings Linked lists Stacks and Queues Trees and Graphs along with heaps Bit Manipulation (With C/C++) Sorting and Searching Dynamic Programming with Top Down (Recursive) approach This is me!","title":"Patterns"},{"location":"#other-links","text":"Visit my website here . My Github , More about me , Send me an email .","title":"Other links"},{"location":"blind75/","tags":["Blind 75","ONGOING SERIES"],"text":"Blind 75 problems This blind problems are a curated set of problems by a facebook engineer and is extremely useful for cracking the coding interview. However we've covered some of the problems in the problems sections of every other topics. Here I'll be adding links to those solutions. Find the blind 75 problems on leetcode \\(\\to\\) Linked List problems Reverse a Linked List Detect Cycle in a Linked List Merge 2 Sorted Lists Merge K Sorted lists Remove Nth Node From End Of List Reorder List Heap Merge K Sorted Lists Top K Frequent Elements Find Median from Data Stream Tree Maximum Depth of Binary Tree Same Tree Invert/Flip Binary Tree Binary Tree Maximum Path Sum Binary Tree Level Order Traversal Serialize and Deserialize Binary Tree Subtree of Another Tree Construct Binary Tree from Preorder and Inorder Traversal Validate Binary Search Tree Kth Smallest Element in a BST Lowest Common Ancestor of BST Implement Trie (Prefix Tree) Add and Search Word Word Search II String Longest Substring Without Repeating Characters Longest Repeating Character Replacement Minimum Window Substring Valid Anagram Group Anagrams Valid Parentheses Valid Palindrome Longest Palindromic Substring Palindromic Substrings Encode and Decode Strings (Leetcode Premium) Binary (bitwise operations) Sum of Two Integers Number of 1 Bits Counting Bits Missing Number Reverse Bits Array Two Sum Best Time to Buy and Sell Stock Contains Duplicate Product of Array Except Self Maximum Subarray Maximum Product Subarray Find Minimum in Rotated Sorted Array Search in Rotated Sorted Array 3 Sum Container With Most Water Dynamic Programming Climbing Stairs Coin Change Longest Increasing Subsequence Longest Common Subsequence Word Break Problem Combination Sum House Robber House Robber II Decode Ways Unique Paths Jump Game","title":"Blind 75 Problems"},{"location":"blind75/#blind-75-problems","text":"This blind problems are a curated set of problems by a facebook engineer and is extremely useful for cracking the coding interview. However we've covered some of the problems in the problems sections of every other topics. Here I'll be adding links to those solutions. Find the blind 75 problems on leetcode \\(\\to\\) Linked List problems Reverse a Linked List Detect Cycle in a Linked List Merge 2 Sorted Lists Merge K Sorted lists Remove Nth Node From End Of List Reorder List Heap Merge K Sorted Lists Top K Frequent Elements Find Median from Data Stream Tree Maximum Depth of Binary Tree Same Tree Invert/Flip Binary Tree Binary Tree Maximum Path Sum Binary Tree Level Order Traversal Serialize and Deserialize Binary Tree Subtree of Another Tree Construct Binary Tree from Preorder and Inorder Traversal Validate Binary Search Tree Kth Smallest Element in a BST Lowest Common Ancestor of BST Implement Trie (Prefix Tree) Add and Search Word Word Search II String Longest Substring Without Repeating Characters Longest Repeating Character Replacement Minimum Window Substring Valid Anagram Group Anagrams Valid Parentheses Valid Palindrome Longest Palindromic Substring Palindromic Substrings Encode and Decode Strings (Leetcode Premium) Binary (bitwise operations) Sum of Two Integers Number of 1 Bits Counting Bits Missing Number Reverse Bits Array Two Sum Best Time to Buy and Sell Stock Contains Duplicate Product of Array Except Self Maximum Subarray Maximum Product Subarray Find Minimum in Rotated Sorted Array Search in Rotated Sorted Array 3 Sum Container With Most Water Dynamic Programming Climbing Stairs Coin Change Longest Increasing Subsequence Longest Common Subsequence Word Break Problem Combination Sum House Robber House Robber II Decode Ways Unique Paths Jump Game","title":"Blind 75 problems"},{"location":"bss/","tags":["Medium","Binary Search","One day to complete"],"text":"Binary Search Problems Whenever a sorted array is given try to apply the binary search on that. This divides the array into two parts and only works on the other part. Recursion equation \\(T(n) = T(\\frac{N}{2}) + C\\) Toy problem to start Problem Statement Find the ceil of a target number for given set of numbers. That is find the smallest number that is greater or equal to the target number from the given array only. Example Given Array: [2, 3, 4, 5, 6, 7, 8, 10] Target: 7.9 Return: 8 Target: 8.2 Return 10 Approach This is exactly the binary search problem but instead of reporting that we don't find the target number, if we don't find the target number, we return the next biggest number. If the number is not found it means that the target number is not present, we have to return the next biggest number. Now the while loop will break at end < start . So the start pointer will be pointing to the next biggest number. def ceil ( array : list [ int ], target : int ) -> int : # Run the actual binary search algorithm and return the element if found start : int = 0 end : int = len ( array ) - 1 while start < end : middle : int = int (( start + end ) / 2 ) if array [ middle ] < target : start = middle + 1 elif array [ middle ] > target : end = middle - 1 else : return array [ middle ] # If the element is not found, then the while loop's start and end pointer crosses # each other and the start pointer points to the smallest element larger than the # target element. return array [ start ] Test Cases [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=9 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=6.25 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=6.7 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=6.1 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=3.27 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=3 print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 9 ), \"Actual should be 10\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.25 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.7 ), \"Actual should be 6.7\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.1 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3.27 ), \"Actual should be 5\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3 ), \"Actual should be 3\" ) Answer is: 10 Actual should be 10 Answer is: 6.6 Actual should be 6.6 Answer is: 6.7 Actual should be 6.7 Answer is: 6.6 Actual should be 6.6 Answer is: 5 Actual should be 5 Answer is: 3 Actual should be 3 Find out the Nth Root of a given element. Problem Statement For a given N and a number K, find \\(\\sqrt[N]{K}\\) . Approach It is obvious that the root of the number should lie between \\(\\{1, 2, ..., K\\}\\) . Now take the avg and reduce the search space to \\(\\{1, 2, ..., \\frac{K}{2}\\}\\) or \\(\\{\\frac{K}{2}, ..., K\\}\\) . Repeat until the difference between higher bound and lower bound is less than some \\(\\epsilon = 10^{-6}\\) from typing import Union THRESHOLD = 1e-6 def get_N_power ( value : int , root : int ): answer : int = 1 while root > 0 : answer *= value root -= 1 return answer def find_n_th_root ( number : int , root : int ) -> Union [ int , float ]: # The nth root lies between the 1, and the number start : int = 1 end : int = number while ( end - start ) > THRESHOLD : middle : float = ( start + end ) / 2.0 if get_N_power ( middle , root ) > number : end = middle elif get_N_power ( middle , root ) < number : start = middle else : return middle return start , end find_n_th_root ( 1024 , 2 ) # -> (31.999999971129, 32.000000923871994) import math math . sqrt ( 1024 ) # Successfully verified -> 32.0 # Some more test cases print ( \"Our Function call returns in range:\" , find_n_th_root ( 1024 , 2 ), \"Original Values\" , math . sqrt ( 1024 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 256 , 4 ), \"Original Values\" , math . sqrt ( math . sqrt ( 256 ))) print ( \"Our Function call returns in range:\" , find_n_th_root ( 128 , 2 ), \"Original Values\" , math . sqrt ( 128 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 3 , 2 ), \"Original Values\" , math . sqrt ( 3 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 81 , 3 )) Our Function call returns in range: (31.999999971129, 32.000000923871994) Original Values 32.0 Our Function call returns in range: (3.9999998211860657, 4.000000771135092) Original Values 4.0 Our Function call returns in range: (11.313708141446114, 11.31370908766985) Original Values 11.313708498984761 Our Function call returns in range: (1.7320499420166016, 1.732050895690918) Original Values 1.7320508075688772 Our Function call returns in range: (4.326748609542847, 4.326749205589294) Median of Row Wise Sorted Matrix Problem Statement We are given a row-wise sorted matrix of size \\(r*c\\) , we need to find the median of the matrix given. It is assumed that \\(r*c\\) is always odd. Example Input : 1 3 5 2 6 9 3 6 9 Output : Median is 5 If we put all the values in a sorted array A[] = 1 2 3 3 5 6 6 9 9) Input: 1 3 4 2 5 6 7 8 9 Output: Median is 5 Constraints Each entry in the array is from \\(1 \\to 10^9\\) R and C are always odd. Apporach Naive Approach Iterate over all the elements, and then sort them, then return the middle element. Time Complexity for this naive apporach \\(O(NM)\\) for the traversal, \\(O(NM \\log MN)\\) for Sorting and, Constant \\(O(1)\\) time for the middle element. So total of \\(O(NM \\log MN)\\) . Space Complexity \\(O(NM)\\) Extra space is required. More optimized apporach","title":"Binary Search"},{"location":"bss/#binary-search-problems","text":"Whenever a sorted array is given try to apply the binary search on that. This divides the array into two parts and only works on the other part. Recursion equation \\(T(n) = T(\\frac{N}{2}) + C\\)","title":"Binary Search Problems"},{"location":"bss/#toy-problem-to-start","text":"","title":"Toy problem to start"},{"location":"bss/#problem-statement","text":"Find the ceil of a target number for given set of numbers. That is find the smallest number that is greater or equal to the target number from the given array only.","title":"Problem Statement"},{"location":"bss/#example","text":"Given Array: [2, 3, 4, 5, 6, 7, 8, 10] Target: 7.9 Return: 8 Target: 8.2 Return 10","title":"Example"},{"location":"bss/#approach","text":"This is exactly the binary search problem but instead of reporting that we don't find the target number, if we don't find the target number, we return the next biggest number. If the number is not found it means that the target number is not present, we have to return the next biggest number. Now the while loop will break at end < start . So the start pointer will be pointing to the next biggest number. def ceil ( array : list [ int ], target : int ) -> int : # Run the actual binary search algorithm and return the element if found start : int = 0 end : int = len ( array ) - 1 while start < end : middle : int = int (( start + end ) / 2 ) if array [ middle ] < target : start = middle + 1 elif array [ middle ] > target : end = middle - 1 else : return array [ middle ] # If the element is not found, then the while loop's start and end pointer crosses # each other and the start pointer points to the smallest element larger than the # target element. return array [ start ] Test Cases [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=9 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=6.25 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=6.7 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=6.1 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=3.27 [2, 3, 5, 6, 6.6, 6.7, 7, 10], target=3 print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 9 ), \"Actual should be 10\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.25 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.7 ), \"Actual should be 6.7\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 6.1 ), \"Actual should be 6.6\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3.27 ), \"Actual should be 5\" ) print ( \"Answer is:\" , ceil ([ 2 , 3 , 5 , 6 , 6.6 , 6.7 , 7 , 10 ], target = 3 ), \"Actual should be 3\" ) Answer is: 10 Actual should be 10 Answer is: 6.6 Actual should be 6.6 Answer is: 6.7 Actual should be 6.7 Answer is: 6.6 Actual should be 6.6 Answer is: 5 Actual should be 5 Answer is: 3 Actual should be 3","title":"Approach"},{"location":"bss/#find-out-the-nth-root-of-a-given-element","text":"","title":"Find out the Nth Root of a given element."},{"location":"bss/#problem-statement_1","text":"For a given N and a number K, find \\(\\sqrt[N]{K}\\) .","title":"Problem Statement"},{"location":"bss/#approach_1","text":"It is obvious that the root of the number should lie between \\(\\{1, 2, ..., K\\}\\) . Now take the avg and reduce the search space to \\(\\{1, 2, ..., \\frac{K}{2}\\}\\) or \\(\\{\\frac{K}{2}, ..., K\\}\\) . Repeat until the difference between higher bound and lower bound is less than some \\(\\epsilon = 10^{-6}\\) from typing import Union THRESHOLD = 1e-6 def get_N_power ( value : int , root : int ): answer : int = 1 while root > 0 : answer *= value root -= 1 return answer def find_n_th_root ( number : int , root : int ) -> Union [ int , float ]: # The nth root lies between the 1, and the number start : int = 1 end : int = number while ( end - start ) > THRESHOLD : middle : float = ( start + end ) / 2.0 if get_N_power ( middle , root ) > number : end = middle elif get_N_power ( middle , root ) < number : start = middle else : return middle return start , end find_n_th_root ( 1024 , 2 ) # -> (31.999999971129, 32.000000923871994) import math math . sqrt ( 1024 ) # Successfully verified -> 32.0 # Some more test cases print ( \"Our Function call returns in range:\" , find_n_th_root ( 1024 , 2 ), \"Original Values\" , math . sqrt ( 1024 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 256 , 4 ), \"Original Values\" , math . sqrt ( math . sqrt ( 256 ))) print ( \"Our Function call returns in range:\" , find_n_th_root ( 128 , 2 ), \"Original Values\" , math . sqrt ( 128 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 3 , 2 ), \"Original Values\" , math . sqrt ( 3 )) print ( \"Our Function call returns in range:\" , find_n_th_root ( 81 , 3 )) Our Function call returns in range: (31.999999971129, 32.000000923871994) Original Values 32.0 Our Function call returns in range: (3.9999998211860657, 4.000000771135092) Original Values 4.0 Our Function call returns in range: (11.313708141446114, 11.31370908766985) Original Values 11.313708498984761 Our Function call returns in range: (1.7320499420166016, 1.732050895690918) Original Values 1.7320508075688772 Our Function call returns in range: (4.326748609542847, 4.326749205589294)","title":"Approach"},{"location":"bss/#median-of-row-wise-sorted-matrix","text":"","title":"Median of Row Wise Sorted Matrix"},{"location":"bss/#problem-statement_2","text":"We are given a row-wise sorted matrix of size \\(r*c\\) , we need to find the median of the matrix given. It is assumed that \\(r*c\\) is always odd.","title":"Problem Statement"},{"location":"bss/#example_1","text":"Input : 1 3 5 2 6 9 3 6 9 Output : Median is 5 If we put all the values in a sorted array A[] = 1 2 3 3 5 6 6 9 9) Input: 1 3 4 2 5 6 7 8 9 Output: Median is 5","title":"Example"},{"location":"bss/#constraints","text":"Each entry in the array is from \\(1 \\to 10^9\\) R and C are always odd.","title":"Constraints"},{"location":"bss/#apporach","text":"","title":"Apporach"},{"location":"bss/#naive-approach","text":"Iterate over all the elements, and then sort them, then return the middle element.","title":"Naive Approach"},{"location":"bss/#time-complexity-for-this-naive-apporach","text":"\\(O(NM)\\) for the traversal, \\(O(NM \\log MN)\\) for Sorting and, Constant \\(O(1)\\) time for the middle element. So total of \\(O(NM \\log MN)\\) .","title":"Time Complexity for this naive apporach"},{"location":"bss/#space-complexity","text":"\\(O(NM)\\) Extra space is required.","title":"Space Complexity"},{"location":"bss/#more-optimized-apporach","text":"","title":"More optimized apporach"},{"location":"freebies/","text":"Freebies Here are things that you get for free if you wish to work in Python. AKDSFramework , a Purely written in Python library containing implementations of various data structures. See documentations here \\(\\to\\) . Benchmarking decorator: Use an one line import to profile any python function, from AKDSFramework.applications.decorators import benchmark . More on this here in this blog post \\(\\to\\) . A Python based caching decorator, to use in Dynamic Programming problems. More on this here in this blog post \\(\\to\\) . A big O analyser, find it here \\(\\to\\) . It works with most of the python programs but is not a good fit for more complex functions. TinyDS , small and simple pythonic implementations for most of your coding problems that are asked in SDE I or II interviews at FAANGs that you will be able to implement on the spot if asked. C++ I actually now prefer to solve algorithm problems in C++ now, so AKDSFramework alternative is here for C++. Click to get it on Github \\(\\to\\) . TinyDSC++ is a simple data structure implementation library that you can remember to implement in an interview setting. Contributing There is some open positions for contribution in AKDSFramework tinyds , and tinydscpp projects. If you are willing to work open source please reach out to me at hey@theroyakash.com . Warning Note that I am currently a masters student in computer science, so I won't be able to provide financial reimbursement for any of the contributions done for the project. If that does not bother you, please reach out.","title":"Freebies"},{"location":"freebies/#freebies","text":"Here are things that you get for free if you wish to work in Python. AKDSFramework , a Purely written in Python library containing implementations of various data structures. See documentations here \\(\\to\\) . Benchmarking decorator: Use an one line import to profile any python function, from AKDSFramework.applications.decorators import benchmark . More on this here in this blog post \\(\\to\\) . A Python based caching decorator, to use in Dynamic Programming problems. More on this here in this blog post \\(\\to\\) . A big O analyser, find it here \\(\\to\\) . It works with most of the python programs but is not a good fit for more complex functions. TinyDS , small and simple pythonic implementations for most of your coding problems that are asked in SDE I or II interviews at FAANGs that you will be able to implement on the spot if asked.","title":"Freebies"},{"location":"freebies/#c","text":"I actually now prefer to solve algorithm problems in C++ now, so AKDSFramework alternative is here for C++. Click to get it on Github \\(\\to\\) . TinyDSC++ is a simple data structure implementation library that you can remember to implement in an interview setting.","title":"C++"},{"location":"freebies/#contributing","text":"There is some open positions for contribution in AKDSFramework tinyds , and tinydscpp projects. If you are willing to work open source please reach out to me at hey@theroyakash.com . Warning Note that I am currently a masters student in computer science, so I won't be able to provide financial reimbursement for any of the contributions done for the project. If that does not bother you, please reach out.","title":"Contributing"},{"location":"LinkedLists/problems/","text":"Linked List problems Implement Linked list and write reverse() Problem Statement Implement Linked list and write reverse() method that reverse the list in-place. Find the problem on Leetcode \\(\\to\\) Approach Using variables we'll reverse the list in \\(O(N)\\) time and \\(O(1)\\) space. C++ Code for Linked List #include <iostream> using std :: cout ; using std :: endl ; using std :: vector ; template < class T > class LinkedListNode { public : T data ; LinkedListNode < T > * next ; }; template < class T > class LinkedList { private : LinkedListNode < T > * head ; LinkedListNode < T > * end ; int classPriveSize ; public : LinkedList () { head = NULL ; end = NULL ; classPriveSize = 0 ; } ~ LinkedList () { Clear (); } void push_back ( T value ) { if ( classPriveSize == 0 ) { LinkedListNode < T > * newNode = new LinkedListNode < T > ; newNode -> data = value ; newNode -> next = NULL ; head = newNode ; end = newNode ; } else { LinkedListNode < T > * newNode = new LinkedListNode < T > ; newNode -> data = value ; newNode -> next = NULL ; end -> next = newNode ; end = newNode ; } classPriveSize ++ ; } T front () { return head -> data ; } T back () { return end -> data ; } }; linkedlist_reverse() method We'll implement linkedlist_reverse() method to reverse a linked list. For doubly linked lists reverse is easy. For doubly linked lists reverse is essentially these 2 steps: - Set list.end() as the new list.begin() - Set list.begin() as the new list.end() . Let's implement this for a singly linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; while ( head != NULL ){ ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } }; Middle of the Linked List Problem Statement Given the head of a singly linked list, return the middle node of the linked list. Find the problem on Leetcode \\(\\to\\) Approach Use 2 pointers with different speed. Return the slow pointer. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head -> next ){ return head ; } ListNode * slowPointer = head ; ListNode * fastPointer = head ; while ( fastPointer != NULL && fastPointer -> next != NULL ){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; } return slowPointer ; } }; Same function implementation but on std::forward_list<typename> container. #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > T findMiddleElement ( forward_list < T > * list ) { // Using 2 pointer approach auto slowPointer = list -> begin (); auto fastPointer = list -> begin (); // Update the slowPointer slowly and fastPointer quickly while ( fastPointer != list -> end () && std :: next ( fastPointer , 1 ) != list -> end ()) { std :: advance ( slowPointer , 1 ); std :: advance ( fastPointer , 2 ); } return * slowPointer ; } Merge 2 sorted lists Find the problem on Leetcode \\(\\to\\) Problem Statement You are given the heads of two sorted linked lists list1 and list2 . Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Input: list1 = [1,2,4], and list2 = [1,3,4] Output: [1,1,2,3,4,4] Approach We'll use the merge subroutine from the merge sort in order to merge these two lists. One problem is that the std::forward_list<typename> do not have a push_back() method. Only have a push_front() method. So we need to reverse the list before returning it. Using std::list<typename> which is a doubly linked list will give us the sorted linked list instead of the reverse sorted linked list. Code #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > forward_list < T > mergeTwoSortedLists ( forward_list < T > * list1 , forward_list < T > * list2 ) { forward_list < T > mergeList ; // Output linked list O(N) space. auto list1_ptr = list1 -> begin (); auto list2_ptr = list2 -> begin (); while ( list1_ptr != list1 -> end () && list2_ptr != list2 -> end ()) { if ( * list1_ptr < * list2_ptr ) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } else if ( * list1_ptr > * list2_ptr ) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } else { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); std :: advance ( list2_ptr , 1 ); } } if ( list1_ptr == list1 -> end () && list2_ptr != list2 -> end ()) { while ( list2_ptr != list2 -> end ()) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } } else if ( list1_ptr != list1 -> end () && list2_ptr == list2 -> end ()) { while ( list1_ptr != list1 -> end ()) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } } mergeList . reverse (); return mergeList ; } Time and Space complexity Time complexity is \\(O(N)\\) and space complexity is \\(O(1)\\) with this implementation. Implementing this problem in-place Step wise iteration explainer Iteration 1 Iteration 2 Iteration 3 Iteration 4 Iteration 5, and so on and the last /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( list1 == NULL ) return list2 ; if ( list2 == NULL ) return list1 ; auto * dummyNode = new ListNode (); auto * temp = dummyNode ; while ( list1 && list2 ){ if ( list1 -> val < list2 -> val ){ temp -> next = list1 ; list1 = list1 -> next ; } else { temp -> next = list2 ; list2 = list2 -> next ; } temp = temp -> next ; } if ( list1 ){ temp -> next = list1 ; } else if ( list2 ){ temp -> next = list2 ; } return dummyNode -> next ; } }; Delete Node in a Linked List Problem on Leetcode \\(\\to\\) Problem Statement Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly. Example Input: For element in [4,5,1,9], we are given the node 5. Remove it from the list. Output: [4,1,9], You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function. Approach Copy over the next node's value to this node. Remove the next node in \\(O(1)\\) time and Space. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void deleteNode ( ListNode * node ) { ListNode * nextNode = node -> next ; int valueAtNext = nextNode -> val ; node -> val = valueAtNext ; ListNode * nextToNextNode = nextNode -> next ; node -> next = nextToNextNode ; delete ( nextNode ); } }; Remove Nth Node From End of List Given the head of a linked list, remove the nth node from the end of the list and return its head Video Explaination Example For elements [1, 2, 3, 4, 5], remove the second node from the last. This will return [1, 2, 3, 5]. Similarly [1] and n = 1 will return []. Constraints Nodes are given either in a forward_list<typename> or in a custom linked list which is defined below. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ - The number of nodes in the list is \\(\\mathcal{N}\\) - 1 <= \\(\\mathcal{N}\\) <= 30 - 0 <= (new ListNode())->val <= 100 - 1 <= n <= \\(\\mathcal{N}\\) [n is within the bounds]. Approach Implementation with two pass Find the size of the linked list. We need to delete the Kth node from the last, means we need to delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) element from the first node (considering index of linked list starts from 1). Now delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) node from the start with the upper solution. struct ListNode { int value ; ListNode * following ; }; ListNode * removeFromEnd ( ListNode * head , int end ){ int size = 0 ; ListNode * start = head ; while ( start ){ start = start -> following ; size ++ ; } if ( size <= 1 ){ // This means only one element is there and removing that // should return nothing. return NULL ; } int indexToRemove = size - end + 1 ; // Index starts from 1 in this case if ( indexToRemove == 1 ){ // Return head->following if indexToRemove is the first one. return head -> following ; } ListNode * prev = head ; ListNode * current = head -> following ; // Mark at the 2nd element int indxpos = 2 ; // Starting from 2nd element while ( indxpos != indexToRemove ){ prev = prev -> following ; current = current -> following ; indxpos += 1 ; } ListNode * following = current -> following ; prev -> following = following ; return head ; } Implementation with one pass only With \\(2\\) pointers we can easily know what is the \\(n^{\\text{th}}\\) node from the back of the list. Observation : If we make 2 pointers at a distance \\(n\\) with each other. Then we move both one by one until the right pointer points to the end of the list \\(\\to\\) then the left pointer points to the \\(n^{\\text{th}}\\) node from the last. A bit modification We have to delete some node. Ideally if we could get a pointer to the previous node, it would be better. Ideally our pointer arrangement should look like this Now walking backwards the starting arrangement of those pointers should be this way To make that arrangement we need to traverse through the list like the following Edge Case There is 2 edgecases here. 1. They ask you to delete the first element [6th last node from the end of a 6 element list]. 2. They give you a one element list. For second case you should add the following check if ( head -> following == NULL ) return NULL ; And for the first case let's run the above algorithm and see what happens. So in this case the size of the linked list is 5 and \\(N = 5\\) . So now at gap = 5 right points to NULL; . We could add the check like this: if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { // Delete the first Node, because right points to NULL return head -> following ; } C++ Code ListNode * removeFromEndOnePass ( ListNode * head , int end ){ if ( head -> following == NULL ) return NULL ; int currentGap = 0 ; ListNode * left = head ; ListNode * right = head ; while ( currentGap != end ){ currentGap ++ ; right = right -> following ; } if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { return head -> following ; } return head ; } Time and space complexity For both the solution \\(O(N)\\) . But 2 pass solution will take more time. Both are cosntant space solution. Add Two Numbers Given as LinkedLists Asked in Amazon, Microsoft, Facebook, Qualcomm. Elsewhere Find the Problem on Leetcode \\(\\to\\) Problem on Binary Search \\(\\to\\) Problem Statement You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Testcase Examples \\(l_1 = [2,4,3] \\:\\&\\: l_2 = [5,6,4]\\) . Corrosponding Output \\(= [7,0,8]\\) Approach Do normal addition from 1st standard and add digit by digit in a new linked list. C++ code #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; forward_list < int > addTwoNumbers ( forward_list < int > * number1 , forward_list < int > * number2 ) { forward_list < int > result ; int digit_sum ; int carryFlag = 0 ; auto n1iter = number1 -> begin (); auto n2iter = number2 -> begin (); while ( n1iter != number1 -> end () && n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = 0 ; } else { digit_sum = 1 ; } digit_sum += ( * n1iter + * n2iter ); if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); std :: advance ( n2iter , 1 ); } // While loop broken meaning both are same or any one // of the numbers have more digits. if ( n1iter != number1 -> end () && n2iter == number2 -> end ()) { // Means n2 got finished and n1 remains while ( n1iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n1iter ); } else { digit_sum = ( * n1iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); } } else if ( n1iter == number1 -> end () && n2iter != number2 -> end ()) { // Means n1 got finished and n2 remains while ( n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n2iter ); } else { digit_sum = ( * n2iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n2iter , 1 ); } } if ( n1iter == number1 -> end () && n2iter == number2 -> end ()) { // Both got ended, then add 1 from the carry to the result if ( carryFlag ) { result . push_front ( 1 ); } } return result ; } C++ code for leetcode with custom definition for singly-linked list Instead of using the stl itself C++ solution on a custom linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode * answer = new ListNode ( -999999 ); ListNode * temp = answer ; int digitLevelSum ; int carry = 0 ; while ( l1 && l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val + l2 -> val ; } else { digitLevelSum = l1 -> val + l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; l2 = l2 -> next ; } if ( l1 != NULL && l2 == NULL ){ while ( l1 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val ; } else { digitLevelSum = l1 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; } } else if ( l1 == NULL && l2 != NULL ){ while ( l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l2 -> val ; } else { digitLevelSum = l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l2 = l2 -> next ; } } if ( ! ( l1 && l2 )){ if ( carry == 1 ){ ListNode * digitLevelEntry = new ListNode ( 1 ); temp -> next = digitLevelEntry ; } } return answer -> next ; } }; Intersection of Two Linked Lists Find the problem on Leetcode \\(\\to\\) Problem Statement Given the heads of two singly linked-lists headA and headB , return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null . Example For the following problem, head1 and head2 are given, find the marked blue intersection point. Approach Brute Force approach For each element in list1 , check if the element is in list2 by comparing the addresses not the values because values can be same in different lists. This takes \\(O(M*N)\\) time and no extra space. Using Hash table As we have to compare if something is present or not we can use hash table to do so. If the node is present in both the list means, they must have the same value and the same address. First we'll create an std::unordered_map<long long int, int> dict; . The key should be long long int address of list nodes, and the value should be the value at that address. Now for each element in the second list check that std::unordered_map<long long int, int> dict; has that value or not. If both the value and the address of the value is present in the second list means this is the first merge point. C++ Code class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { // address to value mapping std :: unordered_map < long long int , int > dict ; // Iterate and Add all the entries of listA auto listAiterator = headA ; while ( listAiterator ){ // Convert the address to a long long int // This is the virtual address only, NOT the physical address. long long int address = reinterpret_cast < long long int > ( listAiterator ); dict . insert ( make_pair ( address , listAiterator -> val )); listAiterator = listAiterator -> next ; } // Now for all element see if the address is already in the map? // If it's in the map means this is the merge point. auto listBiterator = headB ; while ( listBiterator ){ // cast the address to a long long int long long int address = reinterpret_cast < long long int > ( listBiterator ); auto search = dict . find ( address ); if ( search != dict . end ()){ break ; } else { listBiterator = listBiterator -> next ; } } if ( listBiterator ){ return listBiterator ; } return NULL ; } }; Time and Space Complexity As we are going through the list once so the time is \\(O(M + N)\\) where \\(M\\) and \\(N\\) are length of the lists. Additional \\(O(M)\\) or \\(O(N)\\) space is required whatever you choose to store first. Linear time and Constant Space Approach Now check what is the problem here? Here we don't know how long after the merge point occurs. Both the lists can be of any size so we can't compare them directly and advance. But what if we resolve the difference and synchronize them with each other? Let's see what I mean: C++ Code for Most Optimal Approach class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { int sizeA = 0 ; int sizeB = 0 ; // O(max(m, n)) ListNode * Aptr = headA ; ListNode * Bptr = headB ; while ( Aptr || Bptr ){ if ( Aptr ){ sizeA ++ ; Aptr = Aptr -> next ; } if ( Bptr ){ sizeB ++ ; Bptr = Bptr -> next ; } } int headerDifference = sizeA - sizeB ; if ( headerDifference < 0 ){ // Size B is higher // So advance B upto headerDifference while ( headerDifference != 0 ){ headB = headB -> next ; headerDifference ++ ; } } else { // Size A is higher // So advance A upto headerDifference while ( headerDifference != 0 ){ headA = headA -> next ; headerDifference -- ; } } while ( headA && headB ){ if ( headA == headB ){ return headA ; } else { headA = headA -> next ; headB = headB -> next ; } } return NULL ; } }; Time and Space Complexity The size calculation take \\(O(M)\\) where \\(M\\) is the size of the bigger list, and last while loop runs \\(O(N)\\) where \\(N\\) is the size of the smaller list. So overall \\(O(M+N)\\) is the time complexity. No extra space required. Detect a cycle in linked list Problem Statement Given head, the head of a linked list, determine if the linked list has a cycle in it. Approach Create 2 pointers and then move ahead, slow pointer will move one step up, fast pointer will move twos step up, if fast pointer reaches NULL somehow, this means there is no cycle in linked list. If that does not happens and some time after fast == slow , means there is a cycle in linked list. Return true . C++ Code class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next && fast -> next -> next ){ slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ){ return true ; } } return false ; } }; Time and space complexity \\(O(N)\\) time and no extra space. Palindrome Linked list Problem Statement Given the head of a singly linked list, return true if it is a palindrome. Approach With More Space First we push all the value to a new stack. Then we pop the value and compare it to the list head. If same we move forward and if not we return false . C++ Code class Solution { public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; vector < int > stk ; ListNode * headIterator = head ; while ( headIterator ){ stk . push_back ( headIterator -> val ); headIterator = headIterator -> next ; } ListNode * headIterator2 = head ; while ( stk . size () != 0 and headIterator2 ){ if ( stk . back () != headIterator2 -> val ){ return false ; } headIterator2 = headIterator2 -> next ; stk . pop_back (); } return true ; } }; More optimized approach Break down the linked list into 2 parts by finding the middle. From the middle element reverse the linked list. Now again find the middle of the linked list, and then from head go ahead comparing with middle element and move forward. If you find any element which is not equal return false . class Solution { private : ListNode * reverseSubRoutine ( ListNode * head ){ ListNode * current = head ; ListNode * prev = NULL ; while ( current ){ ListNode * nextToCurrent = current -> next ; current -> next = prev ; prev = current ; current = nextToCurrent ; } return prev ; } ListNode * findMidPoint ( ListNode * head ){ ListNode * slow = head ; ListNode * fast = head ; while ( fast and fast -> next ){ slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } int listSize ( ListNode * head ){ int sz = 0 ; ListNode * i_ptr = head ; while ( i_ptr ){ i_ptr = i_ptr -> next ; sz ++ ; } return sz ; } public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; ListNode * midpoint = findMidPoint ( head ); // Reverse from mid point ListNode * reversedHead = reverseSubRoutine ( midpoint ); ListNode * traverse = head ; while ( traverse -> next != midpoint ){ traverse = traverse -> next ; } traverse -> next = reversedHead ; // Now the thing is reversed. // Now get the length of the list int size = listSize ( head ); if ( size % 2 != 0 ){ // The list is not even length means there is one random element at the middle ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler -> next ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } else { // The list is even length. ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } return true ; } }; Find the starting point of cycle in linked list Problem on Leetcode \\(\\to\\) Problem Statement Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. Do not modify the linked list. Constraints The number of the nodes in the list is in the range [ \\(0\\) , \\(10^4\\) ]. \\(-10^5\\) <= Node.val <= \\(10^5\\) You solve it using \\(O(1)\\) (i.e. constant) memory, Linked List definition // Definition for singly-linked list. struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( NULL ) {} }; Approach with extra space We can hash all the nodes while traversing the list, If we find a node == nullptr we stop and say NO cycle present. Else if we find a node that has been already hashed then we say this is the entry point of the cycle. Pseudocode for this apporach ListNode * hash = HashTable (); ListNode * node = LinkedListHead (); while ( node ){ if ( hash . contains ( node )){ return node ; } hash ( node ); node = node . next ; } Time and Space complexity Time is \\(O(N)\\) , Space is \\(O(N)\\) for the hashtable. Approach with no extra space First we run the sub-routine of if_has_loop() , That algorithm stops (if linked list has loop) when the slow and the fast pointer points to the same node. If you observe closely this point will be equi-distant from the node where the cycle started as the head to the node where the cycle started. Now we can advance a ref. pointer to head and the slow or fast pointer by 1 until they meet. Video for intuition The following is a video explaining why this apporach works? C++ Code class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == nullptr or head -> next == nullptr ) return nullptr ; ListNode * slowPointer = head ; ListNode * fastPointer = head ; ListNode * traveller = head ; while (( fastPointer != nullptr ) and ( fastPointer -> next != nullptr )){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; if ( slowPointer == fastPointer ){ break ; } } if (( fastPointer ) and ( fastPointer -> next )){ // Means there is cycle in the list while ( slowPointer != traveller ){ slowPointer = slowPointer -> next ; traveller = traveller -> next ; } return traveller ; } // Means there is no cycle in the list return nullptr ; } }; Given the head of a linked list, rotate the list to the right by k places Problem Statement Given the head of a linked list, rotate the list to the right by k places. Test case examples Input: head = [1,2,3,4,5] , k = 2 Output: [4,5,1,2,3] Input: head = [0,1,2], k = 4 Output: [2,0,1] Constraints: The number of nodes in the list is in the range \\([0, 500]\\) \\(-100\\) <= Node.val <= \\(100\\) \\(0\\) <= k <= \\(2 * 10^9\\) Approach First of all the thing is if the size of the linked list is \\(K\\) then doing exactly K rotation is essentially doing nothing. For example So total of \\(k \\text{ mod size of the list}\\) meaningful rotations are actually happening. This is the way we can reduce the high \\(2 * 10^9\\) number down to the range \\(0 \\to 500\\) the size of the list. Now armed with this knowledge, we can think of what it means to be rotating the list? In the above picture observe that rotating this list by 2 step is actually setting the \\(\\text{size} - K^{th}\\) element's next = NULL , and add the last 2 elements to the front of the list. We can approach this via the following way: First set the final element's next = firstNode . Now set the point where it supposed to be the new head by breaking off the prevNode 's next = NULL . C++ Code class Solution { private : pair < int , ListNode *> getSizeAndLastNode ( ListNode * head ){ int size = 0 ; ListNode * headref = head ; while ( headref -> next ){ size ++ ; headref = headref -> next ; } size ++ ; return make_pair ( size , headref ); } public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == NULL || head -> next == NULL ) { return head ; } pair < int , ListNode *> p = getSizeAndLastNode ( head ); int size = p . first ; ListNode * last = p . second ; int numberOfRotation = k % size ; // Number of effective rotation // now last points to the last node // making it full circle last -> next = head ; // figure out the break point? int breakPoint = size - numberOfRotation ; int index = 1 ; while ( index != breakPoint ){ index ++ ; head = head -> next ; } ListNode * newHead = head -> next ; head -> next = nullptr ; return newHead ; } }; Copy List with Random Pointer Find the Problem on leetcode \\(\\to\\) Problem Statement A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val : an integer representing Node.val random_index : the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node. C++ Node definition class Node { public : int val ; Node * next ; Node * random ; Node ( int _val ) { val = _val ; next = NULL ; random = NULL ; } }; Approach Create a new node traveller, which will be returned as the new deep copy of the linked list. For each element in the list create a new node in the deep copy of the list. During this time also record a unordered_map<long long int, long long int> of list nodes and corrosponding deep copy of the node's address. Now for each element in list and deep copy of the list, set the deep copy node's random pointer to the address of map[list.random] . class Solution { public : Node * copyRandomList ( Node * head ) { Node * copy = new Node ( -6969 ); Node * copyTraveller = copy ; Node * traveller = head ; unordered_map < long long int , long long int > map ; while ( traveller ){ long long int thisNodeAddress = reinterpret_cast < long long int > ( traveller ); int thisNodeValue = traveller -> val ; // Create a node copy and store the address here for later mapping. Node * nextCpy = new Node ( thisNodeValue ); copyTraveller -> next = nextCpy ; copyTraveller = copyTraveller -> next ; long long int copyNodeAddress = reinterpret_cast < long long int > ( nextCpy ); map . insert ({ thisNodeAddress , copyNodeAddress }); traveller = traveller -> next ; } Node * traveller1 = copy -> next ; Node * traveller2 = head ; while ( traveller1 and traveller2 ){ traveller1 -> random = reinterpret_cast < Node *> ( map [ reinterpret_cast < long long int > ( traveller2 -> random )]); traveller1 = traveller1 -> next ; traveller2 = traveller2 -> next ; } return copy -> next ; } }; Time and Memory complexity We are traversing the list 2 times so \\(O(\\mathcal{N})\\) time and we are using a map with max of \\(\\mathcal{N}\\) elements so \\(O(\\mathcal{N})\\) memory complexity.","title":"Linked List problems"},{"location":"LinkedLists/problems/#linked-list-problems","text":"","title":"Linked List problems"},{"location":"LinkedLists/problems/#implement-linked-list-and-write-reverse","text":"","title":"Implement Linked list and write reverse()"},{"location":"LinkedLists/problems/#problem-statement","text":"Implement Linked list and write reverse() method that reverse the list in-place. Find the problem on Leetcode \\(\\to\\)","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach","text":"Using variables we'll reverse the list in \\(O(N)\\) time and \\(O(1)\\) space.","title":"Approach"},{"location":"LinkedLists/problems/#c-code-for-linked-list","text":"#include <iostream> using std :: cout ; using std :: endl ; using std :: vector ; template < class T > class LinkedListNode { public : T data ; LinkedListNode < T > * next ; }; template < class T > class LinkedList { private : LinkedListNode < T > * head ; LinkedListNode < T > * end ; int classPriveSize ; public : LinkedList () { head = NULL ; end = NULL ; classPriveSize = 0 ; } ~ LinkedList () { Clear (); } void push_back ( T value ) { if ( classPriveSize == 0 ) { LinkedListNode < T > * newNode = new LinkedListNode < T > ; newNode -> data = value ; newNode -> next = NULL ; head = newNode ; end = newNode ; } else { LinkedListNode < T > * newNode = new LinkedListNode < T > ; newNode -> data = value ; newNode -> next = NULL ; end -> next = newNode ; end = newNode ; } classPriveSize ++ ; } T front () { return head -> data ; } T back () { return end -> data ; } };","title":"C++ Code for Linked List"},{"location":"LinkedLists/problems/#linkedlist_reverse-method","text":"We'll implement linkedlist_reverse() method to reverse a linked list. For doubly linked lists reverse is easy. For doubly linked lists reverse is essentially these 2 steps: - Set list.end() as the new list.begin() - Set list.begin() as the new list.end() . Let's implement this for a singly linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; while ( head != NULL ){ ListNode * next = head -> next ; head -> next = prev ; prev = head ; head = next ; } return prev ; } };","title":"linkedlist_reverse() method"},{"location":"LinkedLists/problems/#middle-of-the-linked-list","text":"","title":"Middle of the Linked List"},{"location":"LinkedLists/problems/#problem-statement_1","text":"Given the head of a singly linked list, return the middle node of the linked list. Find the problem on Leetcode \\(\\to\\)","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach_1","text":"Use 2 pointers with different speed. Return the slow pointer. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head -> next ){ return head ; } ListNode * slowPointer = head ; ListNode * fastPointer = head ; while ( fastPointer != NULL && fastPointer -> next != NULL ){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; } return slowPointer ; } }; Same function implementation but on std::forward_list<typename> container. #include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > T findMiddleElement ( forward_list < T > * list ) { // Using 2 pointer approach auto slowPointer = list -> begin (); auto fastPointer = list -> begin (); // Update the slowPointer slowly and fastPointer quickly while ( fastPointer != list -> end () && std :: next ( fastPointer , 1 ) != list -> end ()) { std :: advance ( slowPointer , 1 ); std :: advance ( fastPointer , 2 ); } return * slowPointer ; }","title":"Approach"},{"location":"LinkedLists/problems/#merge-2-sorted-lists","text":"Find the problem on Leetcode \\(\\to\\)","title":"Merge 2 sorted lists"},{"location":"LinkedLists/problems/#problem-statement_2","text":"You are given the heads of two sorted linked lists list1 and list2 . Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list. Input: list1 = [1,2,4], and list2 = [1,3,4] Output: [1,1,2,3,4,4]","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach_2","text":"We'll use the merge subroutine from the merge sort in order to merge these two lists. One problem is that the std::forward_list<typename> do not have a push_back() method. Only have a push_front() method. So we need to reverse the list before returning it. Using std::list<typename> which is a doubly linked list will give us the sorted linked list instead of the reverse sorted linked list.","title":"Approach"},{"location":"LinkedLists/problems/#code","text":"#include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; template < class T > forward_list < T > mergeTwoSortedLists ( forward_list < T > * list1 , forward_list < T > * list2 ) { forward_list < T > mergeList ; // Output linked list O(N) space. auto list1_ptr = list1 -> begin (); auto list2_ptr = list2 -> begin (); while ( list1_ptr != list1 -> end () && list2_ptr != list2 -> end ()) { if ( * list1_ptr < * list2_ptr ) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } else if ( * list1_ptr > * list2_ptr ) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } else { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); std :: advance ( list2_ptr , 1 ); } } if ( list1_ptr == list1 -> end () && list2_ptr != list2 -> end ()) { while ( list2_ptr != list2 -> end ()) { mergeList . push_front ( * list2_ptr ); std :: advance ( list2_ptr , 1 ); } } else if ( list1_ptr != list1 -> end () && list2_ptr == list2 -> end ()) { while ( list1_ptr != list1 -> end ()) { mergeList . push_front ( * list1_ptr ); std :: advance ( list1_ptr , 1 ); } } mergeList . reverse (); return mergeList ; }","title":"Code"},{"location":"LinkedLists/problems/#time-and-space-complexity","text":"Time complexity is \\(O(N)\\) and space complexity is \\(O(1)\\) with this implementation.","title":"Time and Space complexity"},{"location":"LinkedLists/problems/#implementing-this-problem-in-place","text":"","title":"Implementing this problem in-place"},{"location":"LinkedLists/problems/#step-wise-iteration-explainer","text":"","title":"Step wise iteration explainer"},{"location":"LinkedLists/problems/#iteration-1","text":"","title":"Iteration 1"},{"location":"LinkedLists/problems/#iteration-2","text":"","title":"Iteration 2"},{"location":"LinkedLists/problems/#iteration-3","text":"","title":"Iteration 3"},{"location":"LinkedLists/problems/#iteration-4","text":"","title":"Iteration 4"},{"location":"LinkedLists/problems/#iteration-5-and-so-on-and-the-last","text":"/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * mergeTwoLists ( ListNode * list1 , ListNode * list2 ) { if ( list1 == NULL ) return list2 ; if ( list2 == NULL ) return list1 ; auto * dummyNode = new ListNode (); auto * temp = dummyNode ; while ( list1 && list2 ){ if ( list1 -> val < list2 -> val ){ temp -> next = list1 ; list1 = list1 -> next ; } else { temp -> next = list2 ; list2 = list2 -> next ; } temp = temp -> next ; } if ( list1 ){ temp -> next = list1 ; } else if ( list2 ){ temp -> next = list2 ; } return dummyNode -> next ; } };","title":"Iteration 5, and so on and the last"},{"location":"LinkedLists/problems/#delete-node-in-a-linked-list","text":"Problem on Leetcode \\(\\to\\)","title":"Delete Node in a Linked List"},{"location":"LinkedLists/problems/#problem-statement_3","text":"Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.","title":"Problem Statement"},{"location":"LinkedLists/problems/#example","text":"Input: For element in [4,5,1,9], we are given the node 5. Remove it from the list. Output: [4,1,9], You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.","title":"Example"},{"location":"LinkedLists/problems/#approach_3","text":"Copy over the next node's value to this node. Remove the next node in \\(O(1)\\) time and Space. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public : void deleteNode ( ListNode * node ) { ListNode * nextNode = node -> next ; int valueAtNext = nextNode -> val ; node -> val = valueAtNext ; ListNode * nextToNextNode = nextNode -> next ; node -> next = nextToNextNode ; delete ( nextNode ); } };","title":"Approach"},{"location":"LinkedLists/problems/#remove-nth-node-from-end-of-list","text":"Given the head of a linked list, remove the nth node from the end of the list and return its head","title":"Remove Nth Node From End of List"},{"location":"LinkedLists/problems/#video-explaination","text":"","title":"Video Explaination"},{"location":"LinkedLists/problems/#example_1","text":"For elements [1, 2, 3, 4, 5], remove the second node from the last. This will return [1, 2, 3, 5]. Similarly [1] and n = 1 will return [].","title":"Example"},{"location":"LinkedLists/problems/#constraints","text":"Nodes are given either in a forward_list<typename> or in a custom linked list which is defined below. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ - The number of nodes in the list is \\(\\mathcal{N}\\) - 1 <= \\(\\mathcal{N}\\) <= 30 - 0 <= (new ListNode())->val <= 100 - 1 <= n <= \\(\\mathcal{N}\\) [n is within the bounds].","title":"Constraints"},{"location":"LinkedLists/problems/#approach_4","text":"","title":"Approach"},{"location":"LinkedLists/problems/#implementation-with-two-pass","text":"Find the size of the linked list. We need to delete the Kth node from the last, means we need to delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) element from the first node (considering index of linked list starts from 1). Now delete the \\((\\text{SIZE} - K + 1)^{\\text{th}}\\) node from the start with the upper solution. struct ListNode { int value ; ListNode * following ; }; ListNode * removeFromEnd ( ListNode * head , int end ){ int size = 0 ; ListNode * start = head ; while ( start ){ start = start -> following ; size ++ ; } if ( size <= 1 ){ // This means only one element is there and removing that // should return nothing. return NULL ; } int indexToRemove = size - end + 1 ; // Index starts from 1 in this case if ( indexToRemove == 1 ){ // Return head->following if indexToRemove is the first one. return head -> following ; } ListNode * prev = head ; ListNode * current = head -> following ; // Mark at the 2nd element int indxpos = 2 ; // Starting from 2nd element while ( indxpos != indexToRemove ){ prev = prev -> following ; current = current -> following ; indxpos += 1 ; } ListNode * following = current -> following ; prev -> following = following ; return head ; }","title":"Implementation with two pass"},{"location":"LinkedLists/problems/#implementation-with-one-pass-only","text":"With \\(2\\) pointers we can easily know what is the \\(n^{\\text{th}}\\) node from the back of the list. Observation : If we make 2 pointers at a distance \\(n\\) with each other. Then we move both one by one until the right pointer points to the end of the list \\(\\to\\) then the left pointer points to the \\(n^{\\text{th}}\\) node from the last.","title":"Implementation with one pass only"},{"location":"LinkedLists/problems/#a-bit-modification","text":"We have to delete some node. Ideally if we could get a pointer to the previous node, it would be better. Ideally our pointer arrangement should look like this Now walking backwards the starting arrangement of those pointers should be this way To make that arrangement we need to traverse through the list like the following","title":"A bit modification"},{"location":"LinkedLists/problems/#edge-case","text":"There is 2 edgecases here. 1. They ask you to delete the first element [6th last node from the end of a 6 element list]. 2. They give you a one element list. For second case you should add the following check if ( head -> following == NULL ) return NULL ; And for the first case let's run the above algorithm and see what happens. So in this case the size of the linked list is 5 and \\(N = 5\\) . So now at gap = 5 right points to NULL; . We could add the check like this: if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { // Delete the first Node, because right points to NULL return head -> following ; }","title":"Edge Case"},{"location":"LinkedLists/problems/#c-code","text":"ListNode * removeFromEndOnePass ( ListNode * head , int end ){ if ( head -> following == NULL ) return NULL ; int currentGap = 0 ; ListNode * left = head ; ListNode * right = head ; while ( currentGap != end ){ currentGap ++ ; right = right -> following ; } if ( right ){ ListNode * ref = left -> following ; left -> following = left -> following -> following ; } else { return head -> following ; } return head ; }","title":"C++ Code"},{"location":"LinkedLists/problems/#time-and-space-complexity_1","text":"For both the solution \\(O(N)\\) . But 2 pass solution will take more time. Both are cosntant space solution.","title":"Time and space complexity"},{"location":"LinkedLists/problems/#add-two-numbers-given-as-linkedlists","text":"Asked in Amazon, Microsoft, Facebook, Qualcomm.","title":"Add Two Numbers Given as LinkedLists"},{"location":"LinkedLists/problems/#elsewhere","text":"Find the Problem on Leetcode \\(\\to\\) Problem on Binary Search \\(\\to\\)","title":"Elsewhere"},{"location":"LinkedLists/problems/#problem-statement_4","text":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself.","title":"Problem Statement"},{"location":"LinkedLists/problems/#testcase-examples","text":"\\(l_1 = [2,4,3] \\:\\&\\: l_2 = [5,6,4]\\) . Corrosponding Output \\(= [7,0,8]\\)","title":"Testcase Examples"},{"location":"LinkedLists/problems/#approach_5","text":"Do normal addition from 1st standard and add digit by digit in a new linked list.","title":"Approach"},{"location":"LinkedLists/problems/#c-code_1","text":"#include <forward_list> #include <iostream> using std :: cout ; using std :: endl ; using std :: forward_list ; forward_list < int > addTwoNumbers ( forward_list < int > * number1 , forward_list < int > * number2 ) { forward_list < int > result ; int digit_sum ; int carryFlag = 0 ; auto n1iter = number1 -> begin (); auto n2iter = number2 -> begin (); while ( n1iter != number1 -> end () && n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = 0 ; } else { digit_sum = 1 ; } digit_sum += ( * n1iter + * n2iter ); if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); std :: advance ( n2iter , 1 ); } // While loop broken meaning both are same or any one // of the numbers have more digits. if ( n1iter != number1 -> end () && n2iter == number2 -> end ()) { // Means n2 got finished and n1 remains while ( n1iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n1iter ); } else { digit_sum = ( * n1iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n1iter , 1 ); } } else if ( n1iter == number1 -> end () && n2iter != number2 -> end ()) { // Means n1 got finished and n2 remains while ( n2iter != number2 -> end ()) { if ( carryFlag == 0 ) { digit_sum = ( * n2iter ); } else { digit_sum = ( * n2iter ) + 1 ; } if ( digit_sum >= 10 ) { carryFlag = 1 ; } else { carryFlag = 0 ; } result . push_front ( digit_sum % 10 ); std :: advance ( n2iter , 1 ); } } if ( n1iter == number1 -> end () && n2iter == number2 -> end ()) { // Both got ended, then add 1 from the carry to the result if ( carryFlag ) { result . push_front ( 1 ); } } return result ; }","title":"C++ code"},{"location":"LinkedLists/problems/#c-code-for-leetcode-with-custom-definition-for-singly-linked-list","text":"Instead of using the stl itself C++ solution on a custom linked list. /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode * answer = new ListNode ( -999999 ); ListNode * temp = answer ; int digitLevelSum ; int carry = 0 ; while ( l1 && l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val + l2 -> val ; } else { digitLevelSum = l1 -> val + l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; l2 = l2 -> next ; } if ( l1 != NULL && l2 == NULL ){ while ( l1 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l1 -> val ; } else { digitLevelSum = l1 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l1 = l1 -> next ; } } else if ( l1 == NULL && l2 != NULL ){ while ( l2 ){ digitLevelSum = 0 ; if ( carry == 0 ){ digitLevelSum = l2 -> val ; } else { digitLevelSum = l2 -> val + 1 ; } if ( digitLevelSum >= 10 ){ carry = 1 ; } else { carry = 0 ; } ListNode * digitLevelEntry = new ListNode ( digitLevelSum % 10 ); temp -> next = digitLevelEntry ; temp = digitLevelEntry ; l2 = l2 -> next ; } } if ( ! ( l1 && l2 )){ if ( carry == 1 ){ ListNode * digitLevelEntry = new ListNode ( 1 ); temp -> next = digitLevelEntry ; } } return answer -> next ; } };","title":"C++ code for leetcode with custom definition for singly-linked list"},{"location":"LinkedLists/problems/#intersection-of-two-linked-lists","text":"Find the problem on Leetcode \\(\\to\\)","title":"Intersection of Two Linked Lists"},{"location":"LinkedLists/problems/#problem-statement_5","text":"Given the heads of two singly linked-lists headA and headB , return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null .","title":"Problem Statement"},{"location":"LinkedLists/problems/#example_2","text":"For the following problem, head1 and head2 are given, find the marked blue intersection point.","title":"Example"},{"location":"LinkedLists/problems/#approach_6","text":"","title":"Approach"},{"location":"LinkedLists/problems/#brute-force-approach","text":"For each element in list1 , check if the element is in list2 by comparing the addresses not the values because values can be same in different lists. This takes \\(O(M*N)\\) time and no extra space.","title":"Brute Force approach"},{"location":"LinkedLists/problems/#using-hash-table","text":"As we have to compare if something is present or not we can use hash table to do so. If the node is present in both the list means, they must have the same value and the same address. First we'll create an std::unordered_map<long long int, int> dict; . The key should be long long int address of list nodes, and the value should be the value at that address. Now for each element in the second list check that std::unordered_map<long long int, int> dict; has that value or not. If both the value and the address of the value is present in the second list means this is the first merge point.","title":"Using Hash table"},{"location":"LinkedLists/problems/#c-code_2","text":"class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { // address to value mapping std :: unordered_map < long long int , int > dict ; // Iterate and Add all the entries of listA auto listAiterator = headA ; while ( listAiterator ){ // Convert the address to a long long int // This is the virtual address only, NOT the physical address. long long int address = reinterpret_cast < long long int > ( listAiterator ); dict . insert ( make_pair ( address , listAiterator -> val )); listAiterator = listAiterator -> next ; } // Now for all element see if the address is already in the map? // If it's in the map means this is the merge point. auto listBiterator = headB ; while ( listBiterator ){ // cast the address to a long long int long long int address = reinterpret_cast < long long int > ( listBiterator ); auto search = dict . find ( address ); if ( search != dict . end ()){ break ; } else { listBiterator = listBiterator -> next ; } } if ( listBiterator ){ return listBiterator ; } return NULL ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#time-and-space-complexity_2","text":"As we are going through the list once so the time is \\(O(M + N)\\) where \\(M\\) and \\(N\\) are length of the lists. Additional \\(O(M)\\) or \\(O(N)\\) space is required whatever you choose to store first.","title":"Time and Space Complexity"},{"location":"LinkedLists/problems/#linear-time-and-constant-space-approach","text":"Now check what is the problem here? Here we don't know how long after the merge point occurs. Both the lists can be of any size so we can't compare them directly and advance. But what if we resolve the difference and synchronize them with each other? Let's see what I mean:","title":"Linear time and Constant Space Approach"},{"location":"LinkedLists/problems/#c-code-for-most-optimal-approach","text":"class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { int sizeA = 0 ; int sizeB = 0 ; // O(max(m, n)) ListNode * Aptr = headA ; ListNode * Bptr = headB ; while ( Aptr || Bptr ){ if ( Aptr ){ sizeA ++ ; Aptr = Aptr -> next ; } if ( Bptr ){ sizeB ++ ; Bptr = Bptr -> next ; } } int headerDifference = sizeA - sizeB ; if ( headerDifference < 0 ){ // Size B is higher // So advance B upto headerDifference while ( headerDifference != 0 ){ headB = headB -> next ; headerDifference ++ ; } } else { // Size A is higher // So advance A upto headerDifference while ( headerDifference != 0 ){ headA = headA -> next ; headerDifference -- ; } } while ( headA && headB ){ if ( headA == headB ){ return headA ; } else { headA = headA -> next ; headB = headB -> next ; } } return NULL ; } };","title":"C++ Code for Most Optimal Approach"},{"location":"LinkedLists/problems/#time-and-space-complexity_3","text":"The size calculation take \\(O(M)\\) where \\(M\\) is the size of the bigger list, and last while loop runs \\(O(N)\\) where \\(N\\) is the size of the smaller list. So overall \\(O(M+N)\\) is the time complexity. No extra space required.","title":"Time and Space Complexity"},{"location":"LinkedLists/problems/#detect-a-cycle-in-linked-list","text":"","title":"Detect a cycle in linked list"},{"location":"LinkedLists/problems/#problem-statement_6","text":"Given head, the head of a linked list, determine if the linked list has a cycle in it.","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach_7","text":"Create 2 pointers and then move ahead, slow pointer will move one step up, fast pointer will move twos step up, if fast pointer reaches NULL somehow, this means there is no cycle in linked list. If that does not happens and some time after fast == slow , means there is a cycle in linked list. Return true .","title":"Approach"},{"location":"LinkedLists/problems/#c-code_3","text":"class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next && fast -> next -> next ){ slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ){ return true ; } } return false ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#time-and-space-complexity_4","text":"\\(O(N)\\) time and no extra space.","title":"Time and space complexity"},{"location":"LinkedLists/problems/#palindrome-linked-list","text":"","title":"Palindrome Linked list"},{"location":"LinkedLists/problems/#problem-statement_7","text":"Given the head of a singly linked list, return true if it is a palindrome.","title":"Problem Statement"},{"location":"LinkedLists/problems/#approach-with-more-space","text":"First we push all the value to a new stack. Then we pop the value and compare it to the list head. If same we move forward and if not we return false .","title":"Approach With More Space"},{"location":"LinkedLists/problems/#c-code_4","text":"class Solution { public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; vector < int > stk ; ListNode * headIterator = head ; while ( headIterator ){ stk . push_back ( headIterator -> val ); headIterator = headIterator -> next ; } ListNode * headIterator2 = head ; while ( stk . size () != 0 and headIterator2 ){ if ( stk . back () != headIterator2 -> val ){ return false ; } headIterator2 = headIterator2 -> next ; stk . pop_back (); } return true ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#more-optimized-approach","text":"Break down the linked list into 2 parts by finding the middle. From the middle element reverse the linked list. Now again find the middle of the linked list, and then from head go ahead comparing with middle element and move forward. If you find any element which is not equal return false . class Solution { private : ListNode * reverseSubRoutine ( ListNode * head ){ ListNode * current = head ; ListNode * prev = NULL ; while ( current ){ ListNode * nextToCurrent = current -> next ; current -> next = prev ; prev = current ; current = nextToCurrent ; } return prev ; } ListNode * findMidPoint ( ListNode * head ){ ListNode * slow = head ; ListNode * fast = head ; while ( fast and fast -> next ){ slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } int listSize ( ListNode * head ){ int sz = 0 ; ListNode * i_ptr = head ; while ( i_ptr ){ i_ptr = i_ptr -> next ; sz ++ ; } return sz ; } public : bool isPalindrome ( ListNode * head ) { if ( head == NULL or head -> next == NULL ) return true ; ListNode * midpoint = findMidPoint ( head ); // Reverse from mid point ListNode * reversedHead = reverseSubRoutine ( midpoint ); ListNode * traverse = head ; while ( traverse -> next != midpoint ){ traverse = traverse -> next ; } traverse -> next = reversedHead ; // Now the thing is reversed. // Now get the length of the list int size = listSize ( head ); if ( size % 2 != 0 ){ // The list is not even length means there is one random element at the middle ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler -> next ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } else { // The list is even length. ListNode * newMidPoint = findMidPoint ( head ); ListNode * traveler = newMidPoint ; while ( traveler ){ if ( head -> val != traveler -> val ){ return false ; } traveler = traveler -> next ; head = head -> next ; } } return true ; } };","title":"More optimized approach"},{"location":"LinkedLists/problems/#find-the-starting-point-of-cycle-in-linked-list","text":"Problem on Leetcode \\(\\to\\)","title":"Find the starting point of cycle in linked list"},{"location":"LinkedLists/problems/#problem-statement_8","text":"Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null. Do not modify the linked list.","title":"Problem Statement"},{"location":"LinkedLists/problems/#constraints_1","text":"The number of the nodes in the list is in the range [ \\(0\\) , \\(10^4\\) ]. \\(-10^5\\) <= Node.val <= \\(10^5\\) You solve it using \\(O(1)\\) (i.e. constant) memory,","title":"Constraints"},{"location":"LinkedLists/problems/#linked-list-definition","text":"// Definition for singly-linked list. struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( NULL ) {} };","title":"Linked List definition"},{"location":"LinkedLists/problems/#approach-with-extra-space","text":"We can hash all the nodes while traversing the list, If we find a node == nullptr we stop and say NO cycle present. Else if we find a node that has been already hashed then we say this is the entry point of the cycle.","title":"Approach with extra space"},{"location":"LinkedLists/problems/#pseudocode-for-this-apporach","text":"ListNode * hash = HashTable (); ListNode * node = LinkedListHead (); while ( node ){ if ( hash . contains ( node )){ return node ; } hash ( node ); node = node . next ; }","title":"Pseudocode for this apporach"},{"location":"LinkedLists/problems/#time-and-space-complexity_5","text":"Time is \\(O(N)\\) , Space is \\(O(N)\\) for the hashtable.","title":"Time and Space complexity"},{"location":"LinkedLists/problems/#approach-with-no-extra-space","text":"First we run the sub-routine of if_has_loop() , That algorithm stops (if linked list has loop) when the slow and the fast pointer points to the same node. If you observe closely this point will be equi-distant from the node where the cycle started as the head to the node where the cycle started. Now we can advance a ref. pointer to head and the slow or fast pointer by 1 until they meet.","title":"Approach with no extra space"},{"location":"LinkedLists/problems/#video-for-intuition","text":"The following is a video explaining why this apporach works?","title":"Video for intuition"},{"location":"LinkedLists/problems/#c-code_5","text":"class Solution { public : ListNode * detectCycle ( ListNode * head ) { if ( head == nullptr or head -> next == nullptr ) return nullptr ; ListNode * slowPointer = head ; ListNode * fastPointer = head ; ListNode * traveller = head ; while (( fastPointer != nullptr ) and ( fastPointer -> next != nullptr )){ slowPointer = slowPointer -> next ; fastPointer = fastPointer -> next -> next ; if ( slowPointer == fastPointer ){ break ; } } if (( fastPointer ) and ( fastPointer -> next )){ // Means there is cycle in the list while ( slowPointer != traveller ){ slowPointer = slowPointer -> next ; traveller = traveller -> next ; } return traveller ; } // Means there is no cycle in the list return nullptr ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#given-the-head-of-a-linked-list-rotate-the-list-to-the-right-by-k-places","text":"","title":"Given the head of a linked list, rotate the list to the right by k places"},{"location":"LinkedLists/problems/#problem-statement_9","text":"Given the head of a linked list, rotate the list to the right by k places. Test case examples Input: head = [1,2,3,4,5] , k = 2 Output: [4,5,1,2,3] Input: head = [0,1,2], k = 4 Output: [2,0,1]","title":"Problem Statement"},{"location":"LinkedLists/problems/#constraints_2","text":"The number of nodes in the list is in the range \\([0, 500]\\) \\(-100\\) <= Node.val <= \\(100\\) \\(0\\) <= k <= \\(2 * 10^9\\)","title":"Constraints:"},{"location":"LinkedLists/problems/#approach_8","text":"First of all the thing is if the size of the linked list is \\(K\\) then doing exactly K rotation is essentially doing nothing. For example So total of \\(k \\text{ mod size of the list}\\) meaningful rotations are actually happening. This is the way we can reduce the high \\(2 * 10^9\\) number down to the range \\(0 \\to 500\\) the size of the list. Now armed with this knowledge, we can think of what it means to be rotating the list? In the above picture observe that rotating this list by 2 step is actually setting the \\(\\text{size} - K^{th}\\) element's next = NULL , and add the last 2 elements to the front of the list. We can approach this via the following way: First set the final element's next = firstNode . Now set the point where it supposed to be the new head by breaking off the prevNode 's next = NULL .","title":"Approach"},{"location":"LinkedLists/problems/#c-code_6","text":"class Solution { private : pair < int , ListNode *> getSizeAndLastNode ( ListNode * head ){ int size = 0 ; ListNode * headref = head ; while ( headref -> next ){ size ++ ; headref = headref -> next ; } size ++ ; return make_pair ( size , headref ); } public : ListNode * rotateRight ( ListNode * head , int k ) { if ( head == NULL || head -> next == NULL ) { return head ; } pair < int , ListNode *> p = getSizeAndLastNode ( head ); int size = p . first ; ListNode * last = p . second ; int numberOfRotation = k % size ; // Number of effective rotation // now last points to the last node // making it full circle last -> next = head ; // figure out the break point? int breakPoint = size - numberOfRotation ; int index = 1 ; while ( index != breakPoint ){ index ++ ; head = head -> next ; } ListNode * newHead = head -> next ; head -> next = nullptr ; return newHead ; } };","title":"C++ Code"},{"location":"LinkedLists/problems/#copy-list-with-random-pointer","text":"Find the Problem on leetcode \\(\\to\\)","title":"Copy List with Random Pointer"},{"location":"LinkedLists/problems/#problem-statement_10","text":"A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null. Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list. For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y. Return the head of the copied linked list. The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where: val : an integer representing Node.val random_index : the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.","title":"Problem Statement"},{"location":"LinkedLists/problems/#c-node-definition","text":"class Node { public : int val ; Node * next ; Node * random ; Node ( int _val ) { val = _val ; next = NULL ; random = NULL ; } };","title":"C++ Node definition"},{"location":"LinkedLists/problems/#approach_9","text":"Create a new node traveller, which will be returned as the new deep copy of the linked list. For each element in the list create a new node in the deep copy of the list. During this time also record a unordered_map<long long int, long long int> of list nodes and corrosponding deep copy of the node's address. Now for each element in list and deep copy of the list, set the deep copy node's random pointer to the address of map[list.random] . class Solution { public : Node * copyRandomList ( Node * head ) { Node * copy = new Node ( -6969 ); Node * copyTraveller = copy ; Node * traveller = head ; unordered_map < long long int , long long int > map ; while ( traveller ){ long long int thisNodeAddress = reinterpret_cast < long long int > ( traveller ); int thisNodeValue = traveller -> val ; // Create a node copy and store the address here for later mapping. Node * nextCpy = new Node ( thisNodeValue ); copyTraveller -> next = nextCpy ; copyTraveller = copyTraveller -> next ; long long int copyNodeAddress = reinterpret_cast < long long int > ( nextCpy ); map . insert ({ thisNodeAddress , copyNodeAddress }); traveller = traveller -> next ; } Node * traveller1 = copy -> next ; Node * traveller2 = head ; while ( traveller1 and traveller2 ){ traveller1 -> random = reinterpret_cast < Node *> ( map [ reinterpret_cast < long long int > ( traveller2 -> random )]); traveller1 = traveller1 -> next ; traveller2 = traveller2 -> next ; } return copy -> next ; } };","title":"Approach"},{"location":"LinkedLists/problems/#time-and-memory-complexity","text":"We are traversing the list 2 times so \\(O(\\mathcal{N})\\) time and we are using a map with max of \\(\\mathcal{N}\\) elements so \\(O(\\mathcal{N})\\) memory complexity.","title":"Time and Memory complexity"},{"location":"LinkedLists/stl-usage/","text":"Linked List STL operations Instead of implementing linked list from scratch, better to use the standard template library. C++ stl has 2 linked lists, std::list<typename> is a doubly-linked list data structure , and std::forward_list<typename> is a singly-linked list data structure . std::list<typename> supports constant time insertion and removal of elements from anywhere in the container Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted. Operations front() and back() returns front and back elements from the list in \\(O(1)\\) time. #include <list> #include <iostream> int main () { std :: list < char > letters { 'd' , 'm' , 'g' , 'w' , 't' , 'f' }; if ( ! letters . empty ()) { std :: cout << \"The first character is '\" << letters . front () << \"'. \\n \" ; std :: cout << \"The last character is '\" << letters . back () << \"'. \\n \" ; } } - size() returns size of the list in constant time since C++ 11. #include <list> #include <iostream> int main () { std :: list < int > nums { 1 , 3 , 5 , 7 }; std :: cout << \"nums contains \" << nums . size () << \" elements. \\n \" ; } Operation Modefiers Adding elements, all done in \\(O(1)\\) time. - push_back() - pop_back() - pop_back() - pop_front() Essential operations merge() function merges 2 sorted linked lists. #include <iostream> #include <list> // For help in printing lists std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( const auto & i : list ) { ostr << ' ' << i ; } return ostr ; } int main () { std :: list < int > list1 = { 5 , 9 , 1 , 3 , 3 }; std :: list < int > list2 = { 8 , 7 , 2 , 3 , 4 , 4 }; list1 . sort (); list2 . sort (); std :: cout << \"list1: \" << list1 << '\\n' ; std :: cout << \"list2: \" << list2 << '\\n' ; list1 . merge ( list2 ); std :: cout << \"merged: \" << list1 << '\\n' ; return 0 ; } std::forward_list<typename> front() and end() are available. end() returns the iterator to the next element of the end of the list in constant time. front() is also \\(O(1)\\) and is equivalent to *list.begin() No size() available. But has max_size() method, returns the maximum number of elements the container is able to hold due to system or library implementation limitations. numbers.empty() method checks if the container has no elements, i.e. whether begin() == end() .","title":"Linked List STL Usage"},{"location":"LinkedLists/stl-usage/#linked-list-stl-operations","text":"Instead of implementing linked list from scratch, better to use the standard template library. C++ stl has 2 linked lists, std::list<typename> is a doubly-linked list data structure , and std::forward_list<typename> is a singly-linked list data structure .","title":"Linked List STL operations"},{"location":"LinkedLists/stl-usage/#stdlisttypename","text":"supports constant time insertion and removal of elements from anywhere in the container Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.","title":"std::list&lt;typename&gt;"},{"location":"LinkedLists/stl-usage/#operations","text":"front() and back() returns front and back elements from the list in \\(O(1)\\) time. #include <list> #include <iostream> int main () { std :: list < char > letters { 'd' , 'm' , 'g' , 'w' , 't' , 'f' }; if ( ! letters . empty ()) { std :: cout << \"The first character is '\" << letters . front () << \"'. \\n \" ; std :: cout << \"The last character is '\" << letters . back () << \"'. \\n \" ; } } - size() returns size of the list in constant time since C++ 11. #include <list> #include <iostream> int main () { std :: list < int > nums { 1 , 3 , 5 , 7 }; std :: cout << \"nums contains \" << nums . size () << \" elements. \\n \" ; }","title":"Operations"},{"location":"LinkedLists/stl-usage/#operation-modefiers","text":"Adding elements, all done in \\(O(1)\\) time. - push_back() - pop_back() - pop_back() - pop_front()","title":"Operation Modefiers"},{"location":"LinkedLists/stl-usage/#essential-operations","text":"merge() function merges 2 sorted linked lists. #include <iostream> #include <list> // For help in printing lists std :: ostream & operator << ( std :: ostream & ostr , const std :: list < int >& list ) { for ( const auto & i : list ) { ostr << ' ' << i ; } return ostr ; } int main () { std :: list < int > list1 = { 5 , 9 , 1 , 3 , 3 }; std :: list < int > list2 = { 8 , 7 , 2 , 3 , 4 , 4 }; list1 . sort (); list2 . sort (); std :: cout << \"list1: \" << list1 << '\\n' ; std :: cout << \"list2: \" << list2 << '\\n' ; list1 . merge ( list2 ); std :: cout << \"merged: \" << list1 << '\\n' ; return 0 ; }","title":"Essential operations"},{"location":"LinkedLists/stl-usage/#stdforward_listtypename","text":"front() and end() are available. end() returns the iterator to the next element of the end of the list in constant time. front() is also \\(O(1)\\) and is equivalent to *list.begin() No size() available. But has max_size() method, returns the maximum number of elements the container is able to hold due to system or library implementation limitations. numbers.empty() method checks if the container has no elements, i.e. whether begin() == end() .","title":"std::forward_list&lt;typename&gt;"},{"location":"arrays/array-problems/","text":"Problems on arrays Dutch National Flag Partitioning Problem Statement Implemented naively, quicksort has large run times and deep function call stacks on arrays with many duplicates because the subarrays may differ greatly in size. One solution is to reorder the array so that all elements less than the pivot appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. This is known as Dutch national flag partitioning, because the Dutch national flag consists of three horizontal bands, each in a different color. Solution Pattern Main thing to do in this problem is to make groups of elements whose values are less, equal, more than the target. For \\(O(N)\\) space solutions we can create three new arrays called less, more, equal and put values into it during the traversal. For \\(O(1)\\) space solutions we can do these steps: Do - inplace grouping of all the less than target elements during the first pass, Do - inplace grouping of all the greater than target elements during the next pass. During this pass if we find one element that is greater than the target we can say that \"Hey! we have entered into the less subarray\", so we can break out of the loop. Total time complexity is \\(O(N)\\) for the first pass and on an average \\(O(\\frac{N}{2})\\) in the second pass. Total of \\(O(N)\\) . def dutch_flag_partition ( pivot_index : int , A : list [ int ]) -> None : pivot_value : int = A [ pivot_index ] small : int = 0 # Group all the smaller elements together at the start # This is in-place grouping of elements smaller than some target for i in range ( len ( A )): if A [ i ] < pivot_value : A [ small ], A [ i ] = A [ i ], A [ small ] small += 1 # Group all the larger elements together at the end larger : int = len ( A ) - 1 for i in reversed ( range ( len ( A ))): if A [ i ] < pivot_value : break elif A [ i ] > pivot_value : A [ i ], A [ larger ] = A [ larger ], A [ i ] larger -= 1 Test Cases Test PASSED (204/204) [ 8 ms] Average running time: 65 us Median running time: 13 us Similar problems Given an array of n objects with keys that takes on of four values, reorder the array so that all the objects that have the same values appear together. \\(O(1)\\) space and \\(O(N)\\) time. String Compression Problem Problem Statement Implement a method to perform basic string compression, like this \"aaaabbbcccaa\" -> \"a4b3c3a2\" My first Approach Make a one key dictionary. Add and count the subsequent characters, Once you find a new element then drop the key, add the contents to the builder string and count again. def string_compressing ( string : str ) -> str : build_string : list [ str ] = [] # using character array instead of string for O(1) append dictionary : dict [ str , int ] = {} for character in string : if character in dictionary : dictionary [ character ] += 1 elif character not in dictionary : if dictionary != {}: # If the dictionary is not empty means we have a new element to consider. # Dump the contents to the build_string and make the dictionary = {} build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) dictionary = {} # Set the new character count to 1 dictionary [ character ] = 1 build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) build_string = \"\" . join ( build_string ) # This does not take O(N^2), takes only O(N) to concatenate a character array to a string. build_string = build_string . replace ( \"1\" , '' ) # O(N) return build_string string_compressing ( \"abbbcccaa\" ) # -> 'ab3c3a2' Time complexity This solution take \\(O(N)\\) time and constant space if you don't count the return string. It uses space to hold an one key dictionary and the return string. Find All Numbers Disappeared in an Array Problem Statement Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums. Examples Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6] Input: nums = [1,1] Output: [2] Constraints n == len(nums) 1 <= n <= 105 1 <= nums[i] <= n Algorithm must run in \\(O(N)\\) time and no extra space. def findDisappearedNumbers ( self , nums : list [ int ]) -> list [ int ]: pass","title":"Array Problems"},{"location":"arrays/array-problems/#problems-on-arrays","text":"","title":"Problems on arrays"},{"location":"arrays/array-problems/#dutch-national-flag-partitioning","text":"","title":"Dutch National Flag Partitioning"},{"location":"arrays/array-problems/#problem-statement","text":"Implemented naively, quicksort has large run times and deep function call stacks on arrays with many duplicates because the subarrays may differ greatly in size. One solution is to reorder the array so that all elements less than the pivot appear first, followed by elements equal to the pivot, followed by elements greater than the pivot. This is known as Dutch national flag partitioning, because the Dutch national flag consists of three horizontal bands, each in a different color.","title":"Problem Statement"},{"location":"arrays/array-problems/#solution-pattern","text":"Main thing to do in this problem is to make groups of elements whose values are less, equal, more than the target. For \\(O(N)\\) space solutions we can create three new arrays called less, more, equal and put values into it during the traversal. For \\(O(1)\\) space solutions we can do these steps: Do - inplace grouping of all the less than target elements during the first pass, Do - inplace grouping of all the greater than target elements during the next pass. During this pass if we find one element that is greater than the target we can say that \"Hey! we have entered into the less subarray\", so we can break out of the loop. Total time complexity is \\(O(N)\\) for the first pass and on an average \\(O(\\frac{N}{2})\\) in the second pass. Total of \\(O(N)\\) . def dutch_flag_partition ( pivot_index : int , A : list [ int ]) -> None : pivot_value : int = A [ pivot_index ] small : int = 0 # Group all the smaller elements together at the start # This is in-place grouping of elements smaller than some target for i in range ( len ( A )): if A [ i ] < pivot_value : A [ small ], A [ i ] = A [ i ], A [ small ] small += 1 # Group all the larger elements together at the end larger : int = len ( A ) - 1 for i in reversed ( range ( len ( A ))): if A [ i ] < pivot_value : break elif A [ i ] > pivot_value : A [ i ], A [ larger ] = A [ larger ], A [ i ] larger -= 1 Test Cases Test PASSED (204/204) [ 8 ms] Average running time: 65 us Median running time: 13 us Similar problems Given an array of n objects with keys that takes on of four values, reorder the array so that all the objects that have the same values appear together. \\(O(1)\\) space and \\(O(N)\\) time.","title":"Solution Pattern"},{"location":"arrays/array-problems/#string-compression-problem","text":"","title":"String Compression Problem"},{"location":"arrays/array-problems/#problem-statement_1","text":"Implement a method to perform basic string compression, like this \"aaaabbbcccaa\" -> \"a4b3c3a2\"","title":"Problem Statement"},{"location":"arrays/array-problems/#my-first-approach","text":"Make a one key dictionary. Add and count the subsequent characters, Once you find a new element then drop the key, add the contents to the builder string and count again. def string_compressing ( string : str ) -> str : build_string : list [ str ] = [] # using character array instead of string for O(1) append dictionary : dict [ str , int ] = {} for character in string : if character in dictionary : dictionary [ character ] += 1 elif character not in dictionary : if dictionary != {}: # If the dictionary is not empty means we have a new element to consider. # Dump the contents to the build_string and make the dictionary = {} build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) dictionary = {} # Set the new character count to 1 dictionary [ character ] = 1 build_string . append ( list ( dictionary . keys ())[ 0 ]) build_string . append ( str ( dictionary [ list ( dictionary . keys ())[ 0 ]])) build_string = \"\" . join ( build_string ) # This does not take O(N^2), takes only O(N) to concatenate a character array to a string. build_string = build_string . replace ( \"1\" , '' ) # O(N) return build_string string_compressing ( \"abbbcccaa\" ) # -> 'ab3c3a2'","title":"My first Approach"},{"location":"arrays/array-problems/#time-complexity","text":"This solution take \\(O(N)\\) time and constant space if you don't count the return string. It uses space to hold an one key dictionary and the return string.","title":"Time complexity"},{"location":"arrays/array-problems/#find-all-numbers-disappeared-in-an-array","text":"","title":"Find All Numbers Disappeared in an Array"},{"location":"arrays/array-problems/#problem-statement_2","text":"Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.","title":"Problem Statement"},{"location":"arrays/array-problems/#examples","text":"Input: nums = [4,3,2,7,8,2,3,1] Output: [5,6] Input: nums = [1,1] Output: [2]","title":"Examples"},{"location":"arrays/array-problems/#constraints","text":"n == len(nums) 1 <= n <= 105 1 <= nums[i] <= n Algorithm must run in \\(O(N)\\) time and no extra space. def findDisappearedNumbers ( self , nums : list [ int ]) -> list [ int ]: pass","title":"Constraints"},{"location":"arrays/arrays/","tags":["introduction","Python"],"text":"Arrays Most of the array problems are typically solved with trivial solutions if \\(O(N)\\) space is given. Not so much when we can not use extra space, but we can still implement the solution without any additional space using some [x:y:z] slice of the array. Example problem Problem Statement ```{admonition} Problem Your input is an array of integers, and you have to reorder its entries so that the even entries appear first. ### Solution We can solve the problem with $O(N)$ space trivially. But to solve the problem with constant space we have to reuse space inside the given array. ![array1](../images/arrays.png) #### Algorithm - Start with both the end. If you find an element odd at the beginning, swap the element with the last element regardless of the status of the last element. Because if you put the first odd element that you see at the end means that odds are at the end. Now your query space reduces from $0 \\to (N-1)$ to $0 \\to (N-2)$ - If you find an element \"even\" at the beginning just skip it because it means that even elements are at the beginning. Now your query space reduces from $0 \\to(N-1)$ to $1 \\to (N-1)$ - Repeat until pointers pointing start of the array crosses pointers pointing end of the array. #### Python Code [Python 3.9 and above] ```python def even_odd_separation(array: list[int]): start: int, end: int = 0, len(array) - 1 # Don't stop until start crosses end while start < end: if array[start] % 2 == 0: # The number at the start is even, so reduce the space to 1 ... n - 1 start += 1 else: # Number infront of the array is odd array[start], array[end] = array[end], array[start] end -= 1 Time and space complexity The above program changes the array in place, so constant space and passes through the array only once, so time complexity is \\(O(N)\\) . ```{admonition} Test cases Test PASSED (1001/1001) [ 7 ms] Average running time: 22 us Median running time: 7 us ## Things to remember before solving Array Questions - Array problems often have simple brute.force solutions that use $O(n)$ space, but there are subtler solutions that use the array itself to reduce space complexity to $O(1)$, - Filling an array from the front is slow, so see if it's possible to write values from the back, with `append()` method, - Instead of deleting an entry from the array try to relocate or MARK as deleted the element. Because deleting element from array is worst case $O(N)$, beacuse all the elements to the right have to swapped one step left, - `A.reverse()` is inplace reversal of array, - `reversed(A)` returns an iterator, - `del A[i]` removes the i th element, - `A[::-1]` reverses the array, - Try using more of the list comprehension methods. ## One toy problem ```{admonition} Problem statement Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. Examples Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Solution Approach Find the possible sum if all the elements are present. Now find what is the actual sum in \\(O(N)\\) time. Subtract from each other to get the absent element. Code def missingNumber ( self , nums : List [ int ]) -> int : max_number : int = len ( nums ) possible_sum : int = ( max_number * ( max_number + 1 )) / 2 actual_sum : int = 0 index : int = 0 while index != len ( nums ): actual_sum += nums [ index ] index += 1 return int ( possible_sum - actual_sum )","title":"Intro to Arrays"},{"location":"arrays/arrays/#arrays","text":"Most of the array problems are typically solved with trivial solutions if \\(O(N)\\) space is given. Not so much when we can not use extra space, but we can still implement the solution without any additional space using some [x:y:z] slice of the array.","title":"Arrays"},{"location":"arrays/arrays/#example-problem","text":"","title":"Example problem"},{"location":"arrays/arrays/#problem-statement","text":"```{admonition} Problem Your input is an array of integers, and you have to reorder its entries so that the even entries appear first. ### Solution We can solve the problem with $O(N)$ space trivially. But to solve the problem with constant space we have to reuse space inside the given array. ![array1](../images/arrays.png) #### Algorithm - Start with both the end. If you find an element odd at the beginning, swap the element with the last element regardless of the status of the last element. Because if you put the first odd element that you see at the end means that odds are at the end. Now your query space reduces from $0 \\to (N-1)$ to $0 \\to (N-2)$ - If you find an element \"even\" at the beginning just skip it because it means that even elements are at the beginning. Now your query space reduces from $0 \\to(N-1)$ to $1 \\to (N-1)$ - Repeat until pointers pointing start of the array crosses pointers pointing end of the array. #### Python Code [Python 3.9 and above] ```python def even_odd_separation(array: list[int]): start: int, end: int = 0, len(array) - 1 # Don't stop until start crosses end while start < end: if array[start] % 2 == 0: # The number at the start is even, so reduce the space to 1 ... n - 1 start += 1 else: # Number infront of the array is odd array[start], array[end] = array[end], array[start] end -= 1","title":"Problem Statement"},{"location":"arrays/arrays/#time-and-space-complexity","text":"The above program changes the array in place, so constant space and passes through the array only once, so time complexity is \\(O(N)\\) . ```{admonition} Test cases Test PASSED (1001/1001) [ 7 ms] Average running time: 22 us Median running time: 7 us ## Things to remember before solving Array Questions - Array problems often have simple brute.force solutions that use $O(n)$ space, but there are subtler solutions that use the array itself to reduce space complexity to $O(1)$, - Filling an array from the front is slow, so see if it's possible to write values from the back, with `append()` method, - Instead of deleting an entry from the array try to relocate or MARK as deleted the element. Because deleting element from array is worst case $O(N)$, beacuse all the elements to the right have to swapped one step left, - `A.reverse()` is inplace reversal of array, - `reversed(A)` returns an iterator, - `del A[i]` removes the i th element, - `A[::-1]` reverses the array, - Try using more of the list comprehension methods. ## One toy problem ```{admonition} Problem statement Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.","title":"Time and space complexity"},{"location":"arrays/arrays/#examples","text":"Input: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Input: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.","title":"Examples"},{"location":"arrays/arrays/#solution","text":"","title":"Solution"},{"location":"arrays/arrays/#approach","text":"Find the possible sum if all the elements are present. Now find what is the actual sum in \\(O(N)\\) time. Subtract from each other to get the absent element.","title":"Approach"},{"location":"arrays/arrays/#code","text":"def missingNumber ( self , nums : List [ int ]) -> int : max_number : int = len ( nums ) possible_sum : int = ( max_number * ( max_number + 1 )) / 2 actual_sum : int = 0 index : int = 0 while index != len ( nums ): actual_sum += nums [ index ] index += 1 return int ( possible_sum - actual_sum )","title":"Code"},{"location":"arrays/sliding-window/","text":"Sliding Windows Problem Introduction Linked list or arrays find something among all contigious sub array of some given size. Example problem Given an array, find the average of all contiguous subarrays of size \u2018K\u2019 in it. For a given array: \\([1, 3, 2, 6, -1, 4, 1, 8, 2]\\) and \\(K=5\\) means find the average of all the contiguous subarrays of size \u20185\u2019 in the given array. For the first 5 numbers (subarray from index 0-4), the average is \\((1+3+2+6\u22121)/5=2.2\\) The average of next 5 numbers (subarray from index 1-5) is: \\((3+2+6-1+4)/5 = 2.8\\) For the next 5 numbers (subarray from index 2-6), the average is: 2.5 and so on. Here is the final output containing the averages of all contiguous subarrays of size 5: Output: [2.2, 2.8, 2.4, 3.6, 2.8] Brute force apprach A brute-force algorithm will be to calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by \u20185\u2019 to find the average. def brute_force ( array : list [ int ], K : int ) -> list [ int ]: # Keep track of the avgs avgs : list [ int ] = [] # Start from 0 and go to the next 5 elements and find the average for i in range ( 0 , len ( array ) - K + 1 ): sum : int = 0 for j in range ( i , i + K ): sum += array [ j ] avg : float = sum / K avgs . append ( avg ) return avgs mainarray : list [ int ] = [ 1 , 3 , 2 , 6 , - 1 , 4 , 1 , 8 , 2 ] K : int = 5 # find max of this size for given array a : list [ int ] = brute_force ( mainarray , K ) from rich.console import Console # For printing purposes console = Console () console . print ( a ) Output [2.2, 2.8, 2.4, 3.6, 2.8] Problems with this apporach Time complexity is huge \\(O(N * K)\\) . We are summing up same elements over and over again. For two consecutive subarrays of size 5 we could just add the new incoming elements and subtract the outgoing elements. This will reduce the cost to \\(O(N)\\) with just one time \\(O(K)\\) summing up program. def optimized ( array : list [ int ], K : int ) -> list [ int ]: if K > len ( array ): raise IndexError ( \"Error Bro\" ) # Keep track of all the averages avgs : list [ int ] = [] # Start from 0 and go to the next K elements and find the average sumtillK : int = 0 for i in range ( 0 , K ): sumtillK += array [ i ] avgs . append ( sumtillK / K ) # If the size of the array is the size of the window then just return if K == len ( array ): return avgs # From K+1 to Last element for each sliding window add the last # element and subtract the first element # Leave the first element and then start from 2nd elemenet # and slide smoothly for i in range ( 1 , len ( array ) - K + 1 ): sumtillK = sumtillK - array [ i - 1 ] + array [ i + K - 1 ] avgs . append ( sumtillK / K ) return avgs Optimized approach with while loop def optimized_while ( array : list [ int ], K : int ) -> list [ int ]: avgs : list [ int ] = [] if K > len ( array ): raise IndexError ( \"Error Bro\" ) sumtillk : int = 0 for i in range ( 0 , K ): sumtillk += array [ i ] avgs . append ( sumtillk / K ) # Leave the first element and then start from 2nd elemenet # and slide smoothly index : int = 1 while index != ( len ( array ) - K + 1 ): sumtillk = sumtillk - array [ index - 1 ] + array [ index + K - 1 ] avgs . append ( sumtillk / K ) index += 1 return avgs b : list [ int ] = optimized ( mainarray , K ) c : list [ int ] = optimized_while ( mainarray , K ) console . print ( b ) console . print ( c ) Output [2.2, 2.8, 2.4, 3.6, 2.8] [2.2, 2.8, 2.4, 3.6, 2.8] Maximum Sum subarray of size K Problem Statement Given an array of positive numbers and a positive number \u2018k\u2019, find the maximum sum of any contiguous subarray of size \u2018k\u2019 . Examples Input: [2, 1, 5, 1, 3, 2], k=3 Output: 9 Explanation: Subarray with maximum sum is [5, 1, 3]. --- Input: [2, 3, 4, 1, 5], k=2 Output: 7 Explanation: Subarray with maximum sum is [3, 4]. Approach [Naive on back of the envelope approach] def mss ( array : list [ int ], k : int ) -> int : maximum : int = 0 sumtillK : int = 0 for i in range ( 0 , k ): sumtillK += array [ i ] maximum = sumtillK idx : int = 1 while idx != len ( array ) - k : sumtillK = sumtillK - array [ idx - 1 ] + array [ idx + k - 1 ] maximum = max ( maximum , sumtillK ) idx += 1 return maximum mainarray : list [ int ] = [ 2 , 1 , 5 , 1 , 3 , 2 ] K : int = 3 # find max of this size for given array a2 : list [ int ] = [ 2 , 3 , 4 , 1 , 5 ] k2 = 2 a : int = mss ( mainarray , K ) print ( a ) # -> 9 b : int = mss ( a2 , k2 ) print ( b ) # -> 7 Time complexity Only one pass of the array so the time complexity is \\(O(N)\\) Smallest subarray with a given sum Problem statement Given an array of positive numbers and a positive number \u2018S\u2019, find the length of the smallest contiguous subarray whose sum is greater than or equal to \u2018S\u2019. Return 0, if no such subarray exists. Examples Input: [2, 1, 5, 2, 3, 2], S=7 Output: 2 Explanation: The smallest subarray with a sum great than or equal to '7' is [5, 2]. --- Input: [2, 1, 5, 2, 8], S=7 Output: 1 Explanation: The smallest subarray with a sum greater than or equal to '7' is [8]. --- Input: [3, 4, 1, 1, 6], S=8 Output: 3 Explanation: Smallest subarrays with a sum greater than or equal to '8' are [3, 4, 1] or [1, 1, 6]. Brute force approach Key takeway approach \ud83d\udca1 For each size of window find out if the sum is greater or equal to the target? testcase1 : list [ int ] = [ 2 , 1 , 5 , 2 , 3 , 2 ] testcase1s : int = 7 testcase2 : list [ int ] = [ 3 , 4 , 1 , 1 , 6 ] testcase2s : int = 8 testcase3 : list [ int ] = [ 2 , 1 , 5 , 2 , 8 ] testcase3s : int = 7 # Brute force approach def ssgs ( array : list [ int ], s : int ) -> int : def subroutine ( array : list [ int ], ws : int , target : int ): if ws == 1 : for entires in array : if entires >= target : return 1 summation : int = 0 for i in range ( 0 , ws ): summation += array [ i ] if summation >= target : return ws index = 1 while index < len ( array ) - ws : summation = summation - array [ index - 1 ] + array [ index + ws - 1 ] if summation >= target : return ws index += 1 return - 1 window_size : int = 1 subroutine_return : int = - 1 while window_size < len ( array ) and subroutine_return == - 1 : subroutine_return = subroutine ( array , window_size , s ) window_size += 1 return subroutine_return from rich.console import Console console = Console () console . print ( ssgs ( testcase1 , testcase1s ), ssgs ( testcase2 , testcase2s ), ssgs ( testcase3 , testcase3s ), ssgs ([ 1 , 2 , 10 , 3 , 4 , 5 , 6 , 7 , 8 ], 17 )) Output 2 3 1 3 Time complexity \\(O(N)\\) work for each size of the window and at most \\(N\\) is the windows size. So \\(N*O(N) = O(N^2)\\) Better Optimized approach First we add up the elements of the array from start until we get the sum at least the target This is the first window size from the array that at least sums upto the target, so we remember the length We will remember the length of the window if we find a smaller window than this that sums at least the target. Coming soon Room for more understanding ... Longest Substring with K Distinct Characters Problem statement Given a string, find the length of the longest substring in it with no more than K distinct characters. Input: String=\"araaci\", K=2 Output: 4 Explanation: The longest substring with no more than '2' distinct characters is \"araa\".","title":"Sliding window problems"},{"location":"arrays/sliding-window/#sliding-windows-problem-introduction","text":"Linked list or arrays find something among all contigious sub array of some given size.","title":"Sliding Windows Problem Introduction"},{"location":"arrays/sliding-window/#example-problem","text":"Given an array, find the average of all contiguous subarrays of size \u2018K\u2019 in it. For a given array: \\([1, 3, 2, 6, -1, 4, 1, 8, 2]\\) and \\(K=5\\) means find the average of all the contiguous subarrays of size \u20185\u2019 in the given array. For the first 5 numbers (subarray from index 0-4), the average is \\((1+3+2+6\u22121)/5=2.2\\) The average of next 5 numbers (subarray from index 1-5) is: \\((3+2+6-1+4)/5 = 2.8\\) For the next 5 numbers (subarray from index 2-6), the average is: 2.5 and so on. Here is the final output containing the averages of all contiguous subarrays of size 5: Output: [2.2, 2.8, 2.4, 3.6, 2.8]","title":"Example problem"},{"location":"arrays/sliding-window/#brute-force-apprach","text":"A brute-force algorithm will be to calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by \u20185\u2019 to find the average. def brute_force ( array : list [ int ], K : int ) -> list [ int ]: # Keep track of the avgs avgs : list [ int ] = [] # Start from 0 and go to the next 5 elements and find the average for i in range ( 0 , len ( array ) - K + 1 ): sum : int = 0 for j in range ( i , i + K ): sum += array [ j ] avg : float = sum / K avgs . append ( avg ) return avgs mainarray : list [ int ] = [ 1 , 3 , 2 , 6 , - 1 , 4 , 1 , 8 , 2 ] K : int = 5 # find max of this size for given array a : list [ int ] = brute_force ( mainarray , K ) from rich.console import Console # For printing purposes console = Console () console . print ( a ) Output [2.2, 2.8, 2.4, 3.6, 2.8]","title":"Brute force apprach"},{"location":"arrays/sliding-window/#problems-with-this-apporach","text":"Time complexity is huge \\(O(N * K)\\) . We are summing up same elements over and over again. For two consecutive subarrays of size 5 we could just add the new incoming elements and subtract the outgoing elements. This will reduce the cost to \\(O(N)\\) with just one time \\(O(K)\\) summing up program. def optimized ( array : list [ int ], K : int ) -> list [ int ]: if K > len ( array ): raise IndexError ( \"Error Bro\" ) # Keep track of all the averages avgs : list [ int ] = [] # Start from 0 and go to the next K elements and find the average sumtillK : int = 0 for i in range ( 0 , K ): sumtillK += array [ i ] avgs . append ( sumtillK / K ) # If the size of the array is the size of the window then just return if K == len ( array ): return avgs # From K+1 to Last element for each sliding window add the last # element and subtract the first element # Leave the first element and then start from 2nd elemenet # and slide smoothly for i in range ( 1 , len ( array ) - K + 1 ): sumtillK = sumtillK - array [ i - 1 ] + array [ i + K - 1 ] avgs . append ( sumtillK / K ) return avgs","title":"Problems with this apporach"},{"location":"arrays/sliding-window/#optimized-approach-with-while-loop","text":"def optimized_while ( array : list [ int ], K : int ) -> list [ int ]: avgs : list [ int ] = [] if K > len ( array ): raise IndexError ( \"Error Bro\" ) sumtillk : int = 0 for i in range ( 0 , K ): sumtillk += array [ i ] avgs . append ( sumtillk / K ) # Leave the first element and then start from 2nd elemenet # and slide smoothly index : int = 1 while index != ( len ( array ) - K + 1 ): sumtillk = sumtillk - array [ index - 1 ] + array [ index + K - 1 ] avgs . append ( sumtillk / K ) index += 1 return avgs b : list [ int ] = optimized ( mainarray , K ) c : list [ int ] = optimized_while ( mainarray , K ) console . print ( b ) console . print ( c ) Output [2.2, 2.8, 2.4, 3.6, 2.8] [2.2, 2.8, 2.4, 3.6, 2.8]","title":"Optimized approach with while loop"},{"location":"arrays/sliding-window/#maximum-sum-subarray-of-size-k","text":"","title":"Maximum Sum subarray of size K"},{"location":"arrays/sliding-window/#problem-statement","text":"Given an array of positive numbers and a positive number \u2018k\u2019, find the maximum sum of any contiguous subarray of size \u2018k\u2019 .","title":"Problem Statement"},{"location":"arrays/sliding-window/#examples","text":"Input: [2, 1, 5, 1, 3, 2], k=3 Output: 9 Explanation: Subarray with maximum sum is [5, 1, 3]. --- Input: [2, 3, 4, 1, 5], k=2 Output: 7 Explanation: Subarray with maximum sum is [3, 4].","title":"Examples"},{"location":"arrays/sliding-window/#approach-naive-on-back-of-the-envelope-approach","text":"def mss ( array : list [ int ], k : int ) -> int : maximum : int = 0 sumtillK : int = 0 for i in range ( 0 , k ): sumtillK += array [ i ] maximum = sumtillK idx : int = 1 while idx != len ( array ) - k : sumtillK = sumtillK - array [ idx - 1 ] + array [ idx + k - 1 ] maximum = max ( maximum , sumtillK ) idx += 1 return maximum mainarray : list [ int ] = [ 2 , 1 , 5 , 1 , 3 , 2 ] K : int = 3 # find max of this size for given array a2 : list [ int ] = [ 2 , 3 , 4 , 1 , 5 ] k2 = 2 a : int = mss ( mainarray , K ) print ( a ) # -> 9 b : int = mss ( a2 , k2 ) print ( b ) # -> 7","title":"Approach [Naive on back of the envelope approach]"},{"location":"arrays/sliding-window/#time-complexity","text":"Only one pass of the array so the time complexity is \\(O(N)\\)","title":"Time complexity"},{"location":"arrays/sliding-window/#smallest-subarray-with-a-given-sum","text":"","title":"Smallest subarray with a given sum"},{"location":"arrays/sliding-window/#problem-statement_1","text":"Given an array of positive numbers and a positive number \u2018S\u2019, find the length of the smallest contiguous subarray whose sum is greater than or equal to \u2018S\u2019. Return 0, if no such subarray exists.","title":"Problem statement"},{"location":"arrays/sliding-window/#examples_1","text":"Input: [2, 1, 5, 2, 3, 2], S=7 Output: 2 Explanation: The smallest subarray with a sum great than or equal to '7' is [5, 2]. --- Input: [2, 1, 5, 2, 8], S=7 Output: 1 Explanation: The smallest subarray with a sum greater than or equal to '7' is [8]. --- Input: [3, 4, 1, 1, 6], S=8 Output: 3 Explanation: Smallest subarrays with a sum greater than or equal to '8' are [3, 4, 1] or [1, 1, 6].","title":"Examples"},{"location":"arrays/sliding-window/#brute-force-approach","text":"Key takeway approach \ud83d\udca1 For each size of window find out if the sum is greater or equal to the target? testcase1 : list [ int ] = [ 2 , 1 , 5 , 2 , 3 , 2 ] testcase1s : int = 7 testcase2 : list [ int ] = [ 3 , 4 , 1 , 1 , 6 ] testcase2s : int = 8 testcase3 : list [ int ] = [ 2 , 1 , 5 , 2 , 8 ] testcase3s : int = 7 # Brute force approach def ssgs ( array : list [ int ], s : int ) -> int : def subroutine ( array : list [ int ], ws : int , target : int ): if ws == 1 : for entires in array : if entires >= target : return 1 summation : int = 0 for i in range ( 0 , ws ): summation += array [ i ] if summation >= target : return ws index = 1 while index < len ( array ) - ws : summation = summation - array [ index - 1 ] + array [ index + ws - 1 ] if summation >= target : return ws index += 1 return - 1 window_size : int = 1 subroutine_return : int = - 1 while window_size < len ( array ) and subroutine_return == - 1 : subroutine_return = subroutine ( array , window_size , s ) window_size += 1 return subroutine_return from rich.console import Console console = Console () console . print ( ssgs ( testcase1 , testcase1s ), ssgs ( testcase2 , testcase2s ), ssgs ( testcase3 , testcase3s ), ssgs ([ 1 , 2 , 10 , 3 , 4 , 5 , 6 , 7 , 8 ], 17 )) Output 2 3 1 3","title":"Brute force approach"},{"location":"arrays/sliding-window/#time-complexity_1","text":"\\(O(N)\\) work for each size of the window and at most \\(N\\) is the windows size. So \\(N*O(N) = O(N^2)\\)","title":"Time complexity"},{"location":"arrays/sliding-window/#better-optimized-approach","text":"First we add up the elements of the array from start until we get the sum at least the target This is the first window size from the array that at least sums upto the target, so we remember the length We will remember the length of the window if we find a smaller window than this that sums at least the target. Coming soon Room for more understanding ...","title":"Better Optimized approach"},{"location":"arrays/sliding-window/#longest-substring-with-k-distinct-characters","text":"","title":"Longest Substring with K Distinct Characters"},{"location":"arrays/sliding-window/#problem-statement_2","text":"Given a string, find the length of the longest substring in it with no more than K distinct characters. Input: String=\"araaci\", K=2 Output: 4 Explanation: The longest substring with no more than '2' distinct characters is \"araa\".","title":"Problem statement"},{"location":"heaps/heap-pq/","text":"Priority Queues and Binary Heaps What are these priority queues? A priority queue is a queue where the most important element is always at the front. The queue can be a max-priority queue (largest element first) or a min-priority queue (smallest element first). So as a data structure designer you have the following options to design a priority queue: An max sorted array or min-sorted array, but downside is inserting new items is slow because they must be inserted in sorted order. or an binary heap (max heap or min heap) Now the question arises what are heaps? The heap is a natural data structure for a priority queue. In fact, the two terms are often used as synonyms. A heap is more efficient than a sorted array because a heap only has to be partially sorted. All heap operations are in the order of \\(\\text{log}\\) or \\(O(\\mathcal{N})\\) . Examples of algorithms that can benefit from a priority queue implemented as heap Dijkstra's algorithm for graph searching uses a priority queue to calculate the minimum cost. A* pathfinding for artificial intelligence. Huffman coding for data compression. This algorithm builds up a compression tree. It repeatedly needs to find the two nodes with the smallest frequencies that do not have a parent node yet. Heap sorting algorithm. Identification You should make and use heap for the problems with the following combination: K & largest or smallest, and solvable by sorting the input seq. STL Usage A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction. The default container is a std::vector<T> underneath. A user-provided Compare can be supplied to change the ordering, e.g. using std::greater<T> would cause the smallest element to appear as the top() [Min Heap]. Functions to remember top() to get the top of the heap. [either min or max element at the time] empty() returns false if the heap is not empty, size() number of elements in the heap, push() to add element takes \\(O(\\log N)\\) comparisons and then the time for push_back() method for the underlying container. By default the std::vector<T> container is used, pop() to remove the top element and build heap. \\(O(\\log N)\\) comparisons and then the time for push_back() method for underlying container. Recommended use of heaps instead of using STL Most likely the input to the problem involving heap is a sequence of numbers given in a std::vector<int> . Now it'll be very rewarding if you use the corman textbook guideline to heapify the vector in-place in \\(O(N)\\) time. I've implemented the following functions for heap usage according to the Corman textbook. You understand these following implementation very well and you should be able to implement them in an interview setting under couple of minutes. Must watch to follow the following code Things to look out before you start First we are implicitly thinking the almost/nearly complete binary tree for heap but actually using a std::vector<int> to represent in memory. In this representation we do not need to store the pointers to the elements for left or right . Instead use the following functions int left ( int index ){ // Assuming 0 based index return index * 2 + 1 ; } int right ( int index ){ return index * 2 + 2 ; } Similarly to get the parent element we just have to write the inverse of the upper two functions int parent ( int childIndex ){ // Return floor (index / 2) return index / 2 ; // integer division returns floor } Now that we know how the heap is structured we are ready to implement 3 helper functions. Why are we doing this instead of std::priority_queue<int> ? If you have the sequence before you start the function, inserting elements into a new std::priority_queue<int> will take \\(O(N) * \\text{one element insertion time} = O(N \\log N)\\) time. With that you are required to use additional space as well. If you use the following approach you will get constant memory heap build in \\(O(N)\\) time, although you'll lose access to the original ordering of elements in the vector. So according to the problem you should be able to switch between these 2 different approaches to build the heap. However it is recommended to use the following approach it takes \\(O(N)\\) time. Heap Build Subroutines There are 2 subroutines according to the the guidelines described in Corman Book. In the following implementation I'll be building a Max Heap, change the code accordingly for min heap implementation. In order to maintain the heap property we call subroutine \\(\\text{MAX_HEAPIFY(A, i)}\\) , cures the heap of one-place violation only. The element at this location might have to go down to the very last level of the heap. So the time complexity for this algorithm is \\(O(h)\\) where \\(h\\) is the height of the heap. The following example shows how one place violation of the heap property can be? Now we can use this \\(\\text{MAX_HEAPIFY(A, i)}\\) in a bottom up manner to convert an unordered array \\(A[0... n]\\) into a max heap. C++ Code void maxHeapify ( std :: vector < int > * vector , int atIndex ){ // Interface: MaxHeapify of `std::vector` vector, and the violation is at `atIndex` // Only solves a single violation // This is for maintaining the heap property int leftChildren = atIndex * 2 + 1 ; int rightChildren = atIndex * 2 + 2 ; int largest = atIndex ; // Now check of what is larger the left children or the current Index? if (( leftChildren < vector -> size ()) && (( * vector )[ leftChildren ] > ( * vector )[ largest ])){ largest = leftChildren ; } // Now check of what is larger the right children or the current Index? if (( rightChildren < vector -> size ()) && (( * vector )[ rightChildren ] > ( * vector )[ largest ])){ largest = rightChildren ; } // If some largest is either present in the left or right children means a swap is needed. if ( largest != atIndex ){ std :: swap (( * vector )[ atIndex ], ( * vector )[ largest ]); // Recursively call to maxHeapify the affected children maxHeapify ( vector , largest ); } } void buildHeap ( std :: vector < int > * vector ){ // Build heap procedure. Runs in O(N) time in-place. // Each leaf-node in a heap is a heap. The procedure BUILD-MAX-HEAP goes through the remaining nodes of the // tree and runs MAX-H EAPIFY on each one int heapSize = vector -> size (); int lastHeadIndex = heapSize / 2 - 1 ; cout << \"Last Head is at \" << lastHeadIndex << \" \\n \" ; for ( int i = lastHeadIndex ; i >= 0 ; i -- ) { maxHeapify ( vector , i ); } }","title":"Heaps Introduction, STL"},{"location":"heaps/heap-pq/#priority-queues-and-binary-heaps","text":"","title":"Priority Queues and Binary Heaps"},{"location":"heaps/heap-pq/#what-are-these-priority-queues","text":"A priority queue is a queue where the most important element is always at the front. The queue can be a max-priority queue (largest element first) or a min-priority queue (smallest element first). So as a data structure designer you have the following options to design a priority queue: An max sorted array or min-sorted array, but downside is inserting new items is slow because they must be inserted in sorted order. or an binary heap (max heap or min heap) Now the question arises what are heaps? The heap is a natural data structure for a priority queue. In fact, the two terms are often used as synonyms. A heap is more efficient than a sorted array because a heap only has to be partially sorted. All heap operations are in the order of \\(\\text{log}\\) or \\(O(\\mathcal{N})\\) . Examples of algorithms that can benefit from a priority queue implemented as heap Dijkstra's algorithm for graph searching uses a priority queue to calculate the minimum cost. A* pathfinding for artificial intelligence. Huffman coding for data compression. This algorithm builds up a compression tree. It repeatedly needs to find the two nodes with the smallest frequencies that do not have a parent node yet. Heap sorting algorithm.","title":"What are these priority queues?"},{"location":"heaps/heap-pq/#identification","text":"You should make and use heap for the problems with the following combination: K & largest or smallest, and solvable by sorting the input seq.","title":"Identification"},{"location":"heaps/heap-pq/#stl-usage","text":"A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction. The default container is a std::vector<T> underneath. A user-provided Compare can be supplied to change the ordering, e.g. using std::greater<T> would cause the smallest element to appear as the top() [Min Heap].","title":"STL Usage"},{"location":"heaps/heap-pq/#functions-to-remember","text":"top() to get the top of the heap. [either min or max element at the time] empty() returns false if the heap is not empty, size() number of elements in the heap, push() to add element takes \\(O(\\log N)\\) comparisons and then the time for push_back() method for the underlying container. By default the std::vector<T> container is used, pop() to remove the top element and build heap. \\(O(\\log N)\\) comparisons and then the time for push_back() method for underlying container.","title":"Functions to remember"},{"location":"heaps/heap-pq/#recommended-use-of-heaps-instead-of-using-stl","text":"Most likely the input to the problem involving heap is a sequence of numbers given in a std::vector<int> . Now it'll be very rewarding if you use the corman textbook guideline to heapify the vector in-place in \\(O(N)\\) time. I've implemented the following functions for heap usage according to the Corman textbook. You understand these following implementation very well and you should be able to implement them in an interview setting under couple of minutes. Must watch to follow the following code","title":"Recommended use of heaps instead of using STL"},{"location":"heaps/heap-pq/#things-to-look-out-before-you-start","text":"First we are implicitly thinking the almost/nearly complete binary tree for heap but actually using a std::vector<int> to represent in memory. In this representation we do not need to store the pointers to the elements for left or right . Instead use the following functions int left ( int index ){ // Assuming 0 based index return index * 2 + 1 ; } int right ( int index ){ return index * 2 + 2 ; } Similarly to get the parent element we just have to write the inverse of the upper two functions int parent ( int childIndex ){ // Return floor (index / 2) return index / 2 ; // integer division returns floor } Now that we know how the heap is structured we are ready to implement 3 helper functions. Why are we doing this instead of std::priority_queue<int> ? If you have the sequence before you start the function, inserting elements into a new std::priority_queue<int> will take \\(O(N) * \\text{one element insertion time} = O(N \\log N)\\) time. With that you are required to use additional space as well. If you use the following approach you will get constant memory heap build in \\(O(N)\\) time, although you'll lose access to the original ordering of elements in the vector. So according to the problem you should be able to switch between these 2 different approaches to build the heap. However it is recommended to use the following approach it takes \\(O(N)\\) time.","title":"Things to look out before you start"},{"location":"heaps/heap-pq/#heap-build-subroutines","text":"There are 2 subroutines according to the the guidelines described in Corman Book. In the following implementation I'll be building a Max Heap, change the code accordingly for min heap implementation. In order to maintain the heap property we call subroutine \\(\\text{MAX_HEAPIFY(A, i)}\\) , cures the heap of one-place violation only. The element at this location might have to go down to the very last level of the heap. So the time complexity for this algorithm is \\(O(h)\\) where \\(h\\) is the height of the heap. The following example shows how one place violation of the heap property can be? Now we can use this \\(\\text{MAX_HEAPIFY(A, i)}\\) in a bottom up manner to convert an unordered array \\(A[0... n]\\) into a max heap.","title":"Heap Build Subroutines"},{"location":"heaps/heap-pq/#c-code","text":"void maxHeapify ( std :: vector < int > * vector , int atIndex ){ // Interface: MaxHeapify of `std::vector` vector, and the violation is at `atIndex` // Only solves a single violation // This is for maintaining the heap property int leftChildren = atIndex * 2 + 1 ; int rightChildren = atIndex * 2 + 2 ; int largest = atIndex ; // Now check of what is larger the left children or the current Index? if (( leftChildren < vector -> size ()) && (( * vector )[ leftChildren ] > ( * vector )[ largest ])){ largest = leftChildren ; } // Now check of what is larger the right children or the current Index? if (( rightChildren < vector -> size ()) && (( * vector )[ rightChildren ] > ( * vector )[ largest ])){ largest = rightChildren ; } // If some largest is either present in the left or right children means a swap is needed. if ( largest != atIndex ){ std :: swap (( * vector )[ atIndex ], ( * vector )[ largest ]); // Recursively call to maxHeapify the affected children maxHeapify ( vector , largest ); } } void buildHeap ( std :: vector < int > * vector ){ // Build heap procedure. Runs in O(N) time in-place. // Each leaf-node in a heap is a heap. The procedure BUILD-MAX-HEAP goes through the remaining nodes of the // tree and runs MAX-H EAPIFY on each one int heapSize = vector -> size (); int lastHeadIndex = heapSize / 2 - 1 ; cout << \"Last Head is at \" << lastHeadIndex << \" \\n \" ; for ( int i = lastHeadIndex ; i >= 0 ; i -- ) { maxHeapify ( vector , i ); } }","title":"C++ Code"},{"location":"heaps/problems/","text":"Heap Problems Kth Largest Element in an Array Questions on leetcode \\(\\to\\) Problem statement Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element. Examples Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 Constraints \\(1 \\leq\\) k <= nums.size() \\(\\leq\\) \\(10^4\\) \\(- 10^4 \\leq \\text{nums[i]} \\leq 10^4\\) Approach There are several approaches, in which 2 are the most efficient: use a k size min heap and put values into the heap until sequence runs out. use the buildHeap() approach to build the given sequence into a heap, then remove top k times. The first approach takes \\(O(N)\\) time and no extra memory. The second approach takes \\(O(N \\log K)\\) time and \\(O(K)\\) extra memory. If you are given a sequence with no ending (data stream) then the second one will be the better approach. Here in the solution we'll be using the second approach. class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater < int >> minHeap ; for ( auto i : nums ){ if ( minHeap . size () != k ){ // Until the min Heap is not of size `K` push elements minHeap . push ( i ); } else { // Now the min Heap is of size K. Push one element [it may be the kth largest] minHeap . push ( i ); // If not the kth largest it'll be removed // Otherwise the k+1th largest will be removed minHeap . pop (); } } return minHeap . top (); } };","title":"Heap Problems"},{"location":"heaps/problems/#heap-problems","text":"","title":"Heap Problems"},{"location":"heaps/problems/#kth-largest-element-in-an-array","text":"Questions on leetcode \\(\\to\\)","title":"Kth Largest Element in an Array"},{"location":"heaps/problems/#problem-statement","text":"Given an integer array nums and an integer k, return the kth largest element in the array. Note that it is the kth largest element in the sorted order, not the kth distinct element.","title":"Problem statement"},{"location":"heaps/problems/#examples","text":"Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4","title":"Examples"},{"location":"heaps/problems/#constraints","text":"\\(1 \\leq\\) k <= nums.size() \\(\\leq\\) \\(10^4\\) \\(- 10^4 \\leq \\text{nums[i]} \\leq 10^4\\)","title":"Constraints"},{"location":"heaps/problems/#approach","text":"There are several approaches, in which 2 are the most efficient: use a k size min heap and put values into the heap until sequence runs out. use the buildHeap() approach to build the given sequence into a heap, then remove top k times. The first approach takes \\(O(N)\\) time and no extra memory. The second approach takes \\(O(N \\log K)\\) time and \\(O(K)\\) extra memory. If you are given a sequence with no ending (data stream) then the second one will be the better approach. Here in the solution we'll be using the second approach. class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { priority_queue < int , vector < int > , greater < int >> minHeap ; for ( auto i : nums ){ if ( minHeap . size () != k ){ // Until the min Heap is not of size `K` push elements minHeap . push ( i ); } else { // Now the min Heap is of size K. Push one element [it may be the kth largest] minHeap . push ( i ); // If not the kth largest it'll be removed // Otherwise the k+1th largest will be removed minHeap . pop (); } } return minHeap . top (); } };","title":"Approach"},{"location":"stacks/problems/","tags":["Stack Problems","SDE 1 and SDE 2","Video Solutions","C++ Code"],"text":"Stack Problems Patterns of questions when to use a stacks. Using Same concept Nearest greater to right or Next Largest Element Nearest greater to left Nearest smaller to right Nearest smaller to left Using the code from the previous concept Stock Span Problem Maximum area of histgram Using the code from the previous two concepts Max area of rectangle in binary matrix Other good problems on stack Rain water trapping Implement Min stack with or without extra space For problems with array think of using stacks, also for problems that uses nested for loops and the inner for loop is dependent upon the outer for loop like the following for ( int i ; i < n ; i ++ ){ for ( int j ; j -> 0 to i ; j ++ ); for ( int j ; j -> i to 0 ; j -- ); for ( int j ; j -> i to n ; j ++ ); for ( int j ; j -> n to i ; j -- ); } there is a huge chance that a stack data structure can be used to optimize the solution. Nearest greater to right or Next Largest Element Problem statement Given an array, print the Next Greater Element to the right for every element. The Next greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. Examples Input Array: [4, 5, 2, 25] Element NGE 4 --> 5 5 --> 25 2 --> 25 25 --> -1 Input Array: [1, 3, 2, 4] Element NGE 1 --> 3 3 --> 4 2 --> 4 4 --> -1 Brute Force approach Traverse the whole array, for each element at i, traverse from i+1 to at worst n to get the first element that is greater than the element at i. This is a pattern for nested for loops and the inner for loop is dependent upon the outer for loop. So we can use a stack to optimize the solution. def brute_force_NGE ( array : list [ int ]) -> None : for i in range ( len ( array )): for j in range ( i + 1 , len ( array )): # ... pass # ... pass return None Optimized solution with Stacks Stack implementation from collections import deque class Stack : def __init__ ( self ): self . container = deque () def pop ( self ): return self . container . pop () def push ( self , value ): self . container . append ( value ) def tos ( self ): return self . container [ - 1 ] if self . container else - 1 def isEmpty ( self ): return len ( self . container ) == 0 Optimized apporach with stacks We start from the very last, and maintain a stack. if the stack is empty means that there is no element that is just greater to the right of this element so return -1 if we don't find anything then push the element onto the stack. if the a[i] element is < the top of the stack means that tos() is the next greater element, if the a[i] is > the top of the stack then we pop() from the stack to find if there is any element > the a[i] , if not return -1. def NGE ( array ): stack = Stack () returnarray = [] end = len ( array ) - 1 while end >= 0 : # unitl we reach to the front if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () <= array [ end ]: stack . pop () if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) elif stack . tos () > array [ end ]: returnarray . append ( stack . tos ()) stack . push ( array [ end ]) end -= 1 return returnarray [:: - 1 ] from rich.console import Console console = Console () console . print ( NGE ([ 1 , 3 , 2 , 4 ])) console . print ( NGE ([ 4 , 5 , 2 , 25 ])) console . print ( NGE ([ 3 , 2 , 1 , 0 , 2 , 4 , 2 , 6 , 9 ])) console . print ( NGE ([ 3 , 2 , 11 , - 0.4 , 2 , 4 , 2 , 6 , 91 ])) Nearest greater to left (NGEle) Problem statement Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. Examples Input Array: [4, 5, 2, 25] Element NGEle 4 --> -1 5 --> -1 2 --> 5 25 --> -1 Input Array: [1, 3, 2, 4] Element NGEle 1 --> -1 3 --> -1 2 --> 3 4 --> -1 Approach Similar to the NGE but we start from the left because we have to operate on the left sub-array. from collections import deque class Stack : def __init__ ( self ): self . s = deque () def push ( self , value ): self . s . append ( value ) def pop ( self ): return self . s . pop () def tos ( self ): return self . s [ - 1 ] def isEmpty ( self ): return len ( self . s ) == 0 def NGEle ( array : list [ int ]): last = len ( array ) out = [] stack = Stack () for i in range ( 0 , last ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () < array [ i ]: stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () > array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NGEle ([ 4 , 5 , 2 , 25 ])) # --> [-1, -1, 5, -1] print ( NGEle ([ 1 , 3 , 2 , 4 ])) # --> [-1, -1, 3, -1] print ( NGEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NGEle ([ 1 ]), NGEle ([]), NGEle ([ - 13 , - 12 , - 11 , - 10 ])) # Some corner cases [-1, -1, 5, 2, -1] [-1] [] [-1, -1, -1, -1] Nearest smaller to left (NSEle) Problem statement Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. Examples Input Array: [4, 5, 2, 25] Element NSEle 4 --> -1 5 --> 4 2 --> -1 25 --> 2 Input Array: [1, 3, 2, 4] Element NSEle 1 --> -1 3 --> 1 2 --> 1 4 --> 2 Approach Drop the bad Brute force approach, we should use a stack Start from the begining and traverse throught the array from \\(0 \\to \\mathcal{N}\\) For each element check the left sub-array using a stack. Pop elements out of the stack if they are greater and push the current element. return -1 for empty stack and tos() if we find elements lesser (i.e. the lesser element). from collections import deque class Stack : def __init__ ( self ): self . s = deque () def pop ( self ): return self . s . pop () def isEmpty ( self ): return len ( self . s ) == 0 def push ( self , value ): self . s . append ( value ) def tos ( self ): return self . s [ - 1 ] def NSEle ( array : list [ int ]) -> list [ int ]: end = len ( array ) stack = Stack () out = [] for i in range ( 0 , end ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and ( stack . tos () > array [ i ]): stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () < array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NSEle ([ 4 , 5 , 2 , 25 ])) print ( NSEle ([ 1 , 3 , 2 , 4 ])) print ( NSEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NSEle ([ - 13 , - 12 , - 11 , - 10 ])) print ( NSEle ([ 1 ]), NSEle ([]), NSEle ([ 13 , 12 , 11 , 10 ])) # Some corner cases [-1, 4, -1, 2] [-1, 1, 1, 2] [-1, 4, -1, -1, 0.5] [-1, -13, -12, -11] [-1] [] [-1, -1, -1, -1] Minimum Stack with extra space Problem Statement Implement a stack with the following methods: MinimumStack() constructs a new instance of a minimum stack append(int val) appends val to the stack peek() retrieves the last element in the stack min() retrieves the minimum value in the stack pop() pops and returns the last element in the stack Each method should be done in \\(\\mathcal{O}(1)\\) time. You can assume that for peek, min and pop, the stack is non-empty when they are called. Constraints \\(n \u2264 100000\\) where n is the number of calls to append, peek, min, and pop. Approach We'll use a two stack approach, one to keep track of all the stack elements ( self.container ) and an auxiliary stack to keep track all the minimum elements. Whenever we find a new min element we'll push it into the self.aux stack. When we find pop() and find same tos() for self.container and self.aux means that the current minimum element is being popped off. So we pop() from both. Python C++ class MinimumStack : def __init__ ( self ): self . container = deque () self . aux = deque () def append ( self , val ): self . container . append ( val ) if len ( self . aux ) == 0 : self . aux . append ( val ) elif len ( self . aux ) > 0 and val < self . aux [ - 1 ]: self . aux . append ( val ) def peek ( self ): return self . container [ - 1 ] def min ( self ): return self . aux [ - 1 ] def pop ( self ): if self . aux [ - 1 ] == self . container [ - 1 ]: k = self . container . pop () self . aux . pop () return k else : return self . container . pop () #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } }; Time Complexity push() takes \\(\\mathcal{O}(1)\\) pop() takes \\(\\mathcal{O}(1)\\) min() takes \\(\\mathcal{O}(1)\\) peek() takes \\(\\mathcal{O}(1)\\) Space Complexity At the very worst total space complexity is \\(\\mathcal{O}(N)\\) Stock Span Problem Problem Statement Equivalent problems are on LeetCode and GeeksForGeeks The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock\u2019s price for all n days. The span Si of the stock\u2019s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than its price on the given day. Example testcase For example, if an array of \\(7\\) days prices is given as \\(\\{100, 80, 60, 70, 60, 75, 85\\}\\) , then the span values for corresponding 7 days are \\(\\{1, 1, 1, 2, 1, 4, 6\\}\\) . For simplicity, For day \\(1\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(3\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(4\\) , there is exactly one day that has more than this day's stock value so return \\(1 + 1 = 2\\) For the last day stock value is \\(85\\) and there is total 5 days before this day which has less stock value: \\(\\{75, 60, 70, 60, 80\\}\\) . So return \\(5+1 =6\\) Approach If we look closely, this problem is really the NGEle problem (Nearest greatest to the left), now instead of returning that we find/count how much (long) ago that nearest smallest was? So the apporach should be Figure out the NGEle first with stack in \\(O(\\mathcal{N})\\) space. Now use as much \\(O(\\mathcal{N})\\) space as possible beacuse you can not reduce it, so keep the program simple. Finally instead of the NGEle array we return the NGEle array along with what was the index number of that NGEle element using a vector of pairs. Now for the stockSpan() function we will return the difference between the position of current element and the position of the NGEle element. Stock Span Problem Brainstorm! #include <iostream> #include <vector> using namespace std ; vector < pair < int , int >> NGEle ( vector < int > vect ){ // Return a pair with NGEle and the position of the NGEle. vector < pair < int , int >> out ; // While storing the values into stack just add the current index to keep track // of where the NGEle is located. vector < pair < int , int >> stack ; // Common NGEle Code [it's the same lolzzzzz]. int index = 0 ; for ( int element : vect ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ element , index }); } else { while (( stack . size () != 0 ) && ( stack . back (). first < element )){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , index }); stack . push_back ({ element , index }); } else if ( stack . back (). first > element ){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ element , index }); } } index ++ ; } return out ; } vector < int > stockSpan ( vector < int > marketCap ){ // find NGEle Values for each day along with their indexes. vector < pair < int , int >> ngele = NGEle ( marketCap ); vector < int > out ; int idx = 0 ; // Now for each element find the distance between it and it's NGEle. for ( auto i : ngele ){ if ( i . second != -1 ){ out . push_back ( idx - i . second + 1 ); } else { out . push_back ( 1 ); } idx ++ ; } return out ; } Let's test the code out. Run the following code to see the code working. int main (){ vector < int > v = { 100 , 70 , 85 , 59 , 15 , 60 , 87 }; vector < pair < int , int >> ngele = NGEle ( v ); vector < int > stkspan = stockSpan ( v ); cout << \"Market CAP\" << endl ; for ( auto j : v ) cout << j << \" \" ; cout << endl ; cout << endl ; // ngele Array for ( auto i : ngele ){ cout << i . first << \" from: \" << i . second << \" \\n \" ; } cout << endl ; cout << \"Stock Span\" << endl ; for ( auto h : stkspan ) cout << h << \" \" ; cout << endl ; return 0 ; } Time Complexity At the very worst case time complexity is \\(O(\\mathcal{N})\\) because we are traversing the marketCap vector only once during the subroutine NGEle() and once in the subroutine stockSpan() . Space Complexity Space complexity is \\(O(\\mathcal{N})\\) . Maximum Area Histogram Problem Statement Similar problem on Leetcode Given an array of integers heights representing the histogram's bar height where the width of each bar is \\(1\\) , return the area of the largest rectangle in the histogram. Examples Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. Thought process Brainstorm! Approach Proper Approach! Time and Space complexity \\(O(\\mathcal{N})\\) time and space is taken. Code Subroutines Two subroutines are needed \\(\\to\\) and these are NSEle and NSR. Neareast smaller to the left and neareast smaller to the right. NSR (NSE, Nearest smaller to the Right) implementation #include <iostream> #include <vector> using std :: vector ; using std :: pair ; vector < pair < int , int >> NSE ( vector < int > vect ){ // Nearest smallest to the right // finds and returns NSE array pair.first -> value // pair.second -> index of the NSE element vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int last = vect . size () - 1 ; while ( last != -1 ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ last ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else if ( stack . back (). first < vect [ last ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ last ], last }); } } last -- ; } return out ; } NSEle (Nearest smaller to the left) implementation vector < pair < int , int >> NSEle ( vector < int > vect ){ vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int start = 0 ; while ( start != vect . size ()){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ start ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else if ( stack . back (). first < vect [ start ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ start ], start }); } } start ++ ; } return out ; } The main function maxAreaHistogram() void maxAreaHistogram ( vector < int > v ){ vector < int > out ; vector < pair < int , int >> nsr = NSE ( v ); // NSR has to-be reverse because we started from the begining std :: reverse ( nsr . begin (), nsr . end ()); vector < pair < int , int >> nsele = NSEle ( v ); int currentMax = -1 ; int index = 0 ; int currentArea = 0 ; for ( int i : v ){ if (( nsr [ index ]. first != -1 ) && ( nsele [ index ]. first != -1 )){ // Both upper and lower bound is within the array // Start from left bound + 1 // end at the upper bound - 1 (don't cosinder the upper bound bcz it's smaller) currentArea = i * (( nsr [ index ]. second - 1 ) - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsr [ index ]. first == -1 ) && ( nsele [ index ]. first != -1 )){ // right side -> -1 no smaller element to the right // Start from left bound + 1, (don't consider the left bound) // end at last currentArea = i * ( v . size () -1 - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsele [ index ]. first == -1 ) && ( nsr [ index ]. first != -1 )){ // No bound to the left // So from index zero -> the upper bound currentArea = i * ( nsr [ index ]. second - 1 + 1 ); } else { // No bound at all -> size * magnitude currentArea = i * ( v . size ()); } out . push_back ( currentArea ); index ++ ; } for ( auto value : out ) std :: cout << BOLDBLUE << value << \" \" ; std :: cout << std :: endl ; } Testing the code out int main (){ // testsForNSE(); // testsForNSEle(); vector < int > v = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 , 5 , 5 }; std :: cout << BOLDCYAN << \"TEST CASE 1\" << RESET << std :: endl ; maxAreaHistogram ( v ); vector < int > v1 = { 2 , 1 , 5 , 6 , 2 , 3 }; std :: cout << BOLDYELLOW << \"TEST CASE 2\" << RESET << std :: endl ; maxAreaHistogram ( v1 ); vector < int > v2 = { 2 , 4 , 1 , 4 , 4 , 5 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2 ); vector < int > v12 = { 5 , 5 , 5 , 5 , 5 , 2 , 4 , 2 , 1 }; std :: cout << BOLDGREEN << \"TEST CASE 3\" << RESET << std :: endl ; maxAreaHistogram ( v12 ); vector < int > v23 = { 3 , 2 , 1 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v23 ); vector < int > v231 = { 10 , 9 , 8 , 7 }; std :: cout << BOLDRED << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v231 ); vector < int > v2321 = { 7 , 8 , 9 , 10 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2321 ); return 0 ; } Output TEST CASE 1 10 4 3 10 12 15 16 15 15 15 TEST CASE 2 2 6 10 6 8 3 TEST CASE 4 4 4 6 12 12 5 TEST CASE 3 25 25 25 25 25 16 4 16 9 TEST CASE 4 3 4 3 TEST CASE 4 10 18 24 28 TEST CASE 4 28 24 18 10 Max Area Rectangle under binary matrix Problem On leetcode \\(\\to\\) Problem Statement Given a binary matrix \\(\\mathcal{M}\\) find out what is the maximum area of the rectangle \\(R\\) , where all elements in \\(R = 1\\) Explanation Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture. Constraints: rows == matrix.length cols == matrix[i].length 1 <= row, cols <= 200 matrix[i][j] is \\(0\\) or \\(1\\) . Approach Proper Approach! We should start with creating histogram for each level. Then we call the MAH() algorithm implemented in the previous question. Then we find the maximum accross all levels. Rain water trapping Same Problem on Leetcode \\(\\to\\) Problem Statement Given \\(N\\) non-negative integers representing an elevation map where the width of each bar is \\(1\\) , compute how much water it can trap after raining. Example Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Explainer Rain Water Trapping Explainer Approach For each building figure out how much water can be trapped on top of its roof. For all buildings add the water trapped on top of its roof. Return the total. To calculate how much water can be trapped on top of its roof, look left and see what is the largest building and look right and see what is the largest building. Get the smallest of those two. That should be the height of water on top of the building. Rain Water Trapping Approach Explainer Solution For each building find the maximum height on both left and right sides [using heaps], then take the minimum of those heights \\(\\to\\) that should be the water height at that location. Subtract the height of the building from it to get how much water is stored on top of the building. For each building add up all the water stored on top of the roof. Return the sum as the total water stored in the system. The Skyline problem Same Problem on Leetcode \\(\\to\\) Problem Statement A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.","title":"Stack Problems"},{"location":"stacks/problems/#stack-problems","text":"Patterns of questions when to use a stacks. Using Same concept Nearest greater to right or Next Largest Element Nearest greater to left Nearest smaller to right Nearest smaller to left Using the code from the previous concept Stock Span Problem Maximum area of histgram Using the code from the previous two concepts Max area of rectangle in binary matrix Other good problems on stack Rain water trapping Implement Min stack with or without extra space For problems with array think of using stacks, also for problems that uses nested for loops and the inner for loop is dependent upon the outer for loop like the following for ( int i ; i < n ; i ++ ){ for ( int j ; j -> 0 to i ; j ++ ); for ( int j ; j -> i to 0 ; j -- ); for ( int j ; j -> i to n ; j ++ ); for ( int j ; j -> n to i ; j -- ); } there is a huge chance that a stack data structure can be used to optimize the solution.","title":"Stack Problems"},{"location":"stacks/problems/#nearest-greater-to-right-or-next-largest-element","text":"","title":"Nearest greater to right or Next Largest Element"},{"location":"stacks/problems/#problem-statement","text":"Given an array, print the Next Greater Element to the right for every element. The Next greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.","title":"Problem statement"},{"location":"stacks/problems/#examples","text":"Input Array: [4, 5, 2, 25] Element NGE 4 --> 5 5 --> 25 2 --> 25 25 --> -1 Input Array: [1, 3, 2, 4] Element NGE 1 --> 3 3 --> 4 2 --> 4 4 --> -1","title":"Examples"},{"location":"stacks/problems/#brute-force-approach","text":"Traverse the whole array, for each element at i, traverse from i+1 to at worst n to get the first element that is greater than the element at i. This is a pattern for nested for loops and the inner for loop is dependent upon the outer for loop. So we can use a stack to optimize the solution. def brute_force_NGE ( array : list [ int ]) -> None : for i in range ( len ( array )): for j in range ( i + 1 , len ( array )): # ... pass # ... pass return None","title":"Brute Force approach"},{"location":"stacks/problems/#optimized-solution-with-stacks","text":"","title":"Optimized solution with Stacks"},{"location":"stacks/problems/#stack-implementation","text":"from collections import deque class Stack : def __init__ ( self ): self . container = deque () def pop ( self ): return self . container . pop () def push ( self , value ): self . container . append ( value ) def tos ( self ): return self . container [ - 1 ] if self . container else - 1 def isEmpty ( self ): return len ( self . container ) == 0","title":"Stack implementation"},{"location":"stacks/problems/#optimized-apporach-with-stacks","text":"We start from the very last, and maintain a stack. if the stack is empty means that there is no element that is just greater to the right of this element so return -1 if we don't find anything then push the element onto the stack. if the a[i] element is < the top of the stack means that tos() is the next greater element, if the a[i] is > the top of the stack then we pop() from the stack to find if there is any element > the a[i] , if not return -1. def NGE ( array ): stack = Stack () returnarray = [] end = len ( array ) - 1 while end >= 0 : # unitl we reach to the front if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () <= array [ end ]: stack . pop () if stack . isEmpty (): stack . push ( array [ end ]) returnarray . append ( - 1 ) elif stack . tos () > array [ end ]: returnarray . append ( stack . tos ()) stack . push ( array [ end ]) end -= 1 return returnarray [:: - 1 ] from rich.console import Console console = Console () console . print ( NGE ([ 1 , 3 , 2 , 4 ])) console . print ( NGE ([ 4 , 5 , 2 , 25 ])) console . print ( NGE ([ 3 , 2 , 1 , 0 , 2 , 4 , 2 , 6 , 9 ])) console . print ( NGE ([ 3 , 2 , 11 , - 0.4 , 2 , 4 , 2 , 6 , 91 ]))","title":"Optimized apporach with stacks"},{"location":"stacks/problems/#nearest-greater-to-left-ngele","text":"","title":"Nearest greater to left (NGEle)"},{"location":"stacks/problems/#problem-statement_1","text":"Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.","title":"Problem statement"},{"location":"stacks/problems/#examples_1","text":"Input Array: [4, 5, 2, 25] Element NGEle 4 --> -1 5 --> -1 2 --> 5 25 --> -1 Input Array: [1, 3, 2, 4] Element NGEle 1 --> -1 3 --> -1 2 --> 3 4 --> -1","title":"Examples"},{"location":"stacks/problems/#approach","text":"Similar to the NGE but we start from the left because we have to operate on the left sub-array. from collections import deque class Stack : def __init__ ( self ): self . s = deque () def push ( self , value ): self . s . append ( value ) def pop ( self ): return self . s . pop () def tos ( self ): return self . s [ - 1 ] def isEmpty ( self ): return len ( self . s ) == 0 def NGEle ( array : list [ int ]): last = len ( array ) out = [] stack = Stack () for i in range ( 0 , last ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and stack . tos () < array [ i ]: stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () > array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NGEle ([ 4 , 5 , 2 , 25 ])) # --> [-1, -1, 5, -1] print ( NGEle ([ 1 , 3 , 2 , 4 ])) # --> [-1, -1, 3, -1] print ( NGEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NGEle ([ 1 ]), NGEle ([]), NGEle ([ - 13 , - 12 , - 11 , - 10 ])) # Some corner cases [-1, -1, 5, 2, -1] [-1] [] [-1, -1, -1, -1]","title":"Approach"},{"location":"stacks/problems/#nearest-smaller-to-left-nsele","text":"","title":"Nearest smaller to left (NSEle)"},{"location":"stacks/problems/#problem-statement_2","text":"Given an array, print the Next Greater Element to the left for every element. The Next greater Element for an element x is the first greater element on the left side of x in the array. Elements for which no greater element exist, consider the next greater element as -1.","title":"Problem statement"},{"location":"stacks/problems/#examples_2","text":"Input Array: [4, 5, 2, 25] Element NSEle 4 --> -1 5 --> 4 2 --> -1 25 --> 2 Input Array: [1, 3, 2, 4] Element NSEle 1 --> -1 3 --> 1 2 --> 1 4 --> 2","title":"Examples"},{"location":"stacks/problems/#approach_1","text":"Drop the bad Brute force approach, we should use a stack Start from the begining and traverse throught the array from \\(0 \\to \\mathcal{N}\\) For each element check the left sub-array using a stack. Pop elements out of the stack if they are greater and push the current element. return -1 for empty stack and tos() if we find elements lesser (i.e. the lesser element). from collections import deque class Stack : def __init__ ( self ): self . s = deque () def pop ( self ): return self . s . pop () def isEmpty ( self ): return len ( self . s ) == 0 def push ( self , value ): self . s . append ( value ) def tos ( self ): return self . s [ - 1 ] def NSEle ( array : list [ int ]) -> list [ int ]: end = len ( array ) stack = Stack () out = [] for i in range ( 0 , end ): if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) else : while not stack . isEmpty () and ( stack . tos () > array [ i ]): stack . pop () if stack . isEmpty (): stack . push ( array [ i ]) out . append ( - 1 ) elif stack . tos () < array [ i ]: out . append ( stack . tos ()) stack . push ( array [ i ]) return out print ( NSEle ([ 4 , 5 , 2 , 25 ])) print ( NSEle ([ 1 , 3 , 2 , 4 ])) print ( NSEle ([ 4 , 5 , 2 , 0.5 , 25 ])) print ( NSEle ([ - 13 , - 12 , - 11 , - 10 ])) print ( NSEle ([ 1 ]), NSEle ([]), NSEle ([ 13 , 12 , 11 , 10 ])) # Some corner cases [-1, 4, -1, 2] [-1, 1, 1, 2] [-1, 4, -1, -1, 0.5] [-1, -13, -12, -11] [-1] [] [-1, -1, -1, -1]","title":"Approach"},{"location":"stacks/problems/#minimum-stack-with-extra-space","text":"","title":"Minimum Stack with extra space"},{"location":"stacks/problems/#problem-statement_3","text":"Implement a stack with the following methods: MinimumStack() constructs a new instance of a minimum stack append(int val) appends val to the stack peek() retrieves the last element in the stack min() retrieves the minimum value in the stack pop() pops and returns the last element in the stack Each method should be done in \\(\\mathcal{O}(1)\\) time. You can assume that for peek, min and pop, the stack is non-empty when they are called.","title":"Problem Statement"},{"location":"stacks/problems/#constraints","text":"\\(n \u2264 100000\\) where n is the number of calls to append, peek, min, and pop.","title":"Constraints"},{"location":"stacks/problems/#approach_2","text":"We'll use a two stack approach, one to keep track of all the stack elements ( self.container ) and an auxiliary stack to keep track all the minimum elements. Whenever we find a new min element we'll push it into the self.aux stack. When we find pop() and find same tos() for self.container and self.aux means that the current minimum element is being popped off. So we pop() from both. Python C++ class MinimumStack : def __init__ ( self ): self . container = deque () self . aux = deque () def append ( self , val ): self . container . append ( val ) if len ( self . aux ) == 0 : self . aux . append ( val ) elif len ( self . aux ) > 0 and val < self . aux [ - 1 ]: self . aux . append ( val ) def peek ( self ): return self . container [ - 1 ] def min ( self ): return self . aux [ - 1 ] def pop ( self ): if self . aux [ - 1 ] == self . container [ - 1 ]: k = self . container . pop () self . aux . pop () return k else : return self . container . pop () #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } };","title":"Approach"},{"location":"stacks/problems/#time-complexity","text":"push() takes \\(\\mathcal{O}(1)\\) pop() takes \\(\\mathcal{O}(1)\\) min() takes \\(\\mathcal{O}(1)\\) peek() takes \\(\\mathcal{O}(1)\\)","title":"Time Complexity"},{"location":"stacks/problems/#space-complexity","text":"At the very worst total space complexity is \\(\\mathcal{O}(N)\\)","title":"Space Complexity"},{"location":"stacks/problems/#stock-span-problem","text":"","title":"Stock Span Problem"},{"location":"stacks/problems/#problem-statement_4","text":"Equivalent problems are on LeetCode and GeeksForGeeks The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock\u2019s price for all n days. The span Si of the stock\u2019s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than its price on the given day.","title":"Problem Statement"},{"location":"stacks/problems/#example-testcase","text":"For example, if an array of \\(7\\) days prices is given as \\(\\{100, 80, 60, 70, 60, 75, 85\\}\\) , then the span values for corresponding 7 days are \\(\\{1, 1, 1, 2, 1, 4, 6\\}\\) . For simplicity, For day \\(1\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(3\\) , no days are before this day that has more than this day's stock value so return \\(1\\) For day \\(4\\) , there is exactly one day that has more than this day's stock value so return \\(1 + 1 = 2\\) For the last day stock value is \\(85\\) and there is total 5 days before this day which has less stock value: \\(\\{75, 60, 70, 60, 80\\}\\) . So return \\(5+1 =6\\)","title":"Example testcase"},{"location":"stacks/problems/#approach_3","text":"If we look closely, this problem is really the NGEle problem (Nearest greatest to the left), now instead of returning that we find/count how much (long) ago that nearest smallest was? So the apporach should be Figure out the NGEle first with stack in \\(O(\\mathcal{N})\\) space. Now use as much \\(O(\\mathcal{N})\\) space as possible beacuse you can not reduce it, so keep the program simple. Finally instead of the NGEle array we return the NGEle array along with what was the index number of that NGEle element using a vector of pairs. Now for the stockSpan() function we will return the difference between the position of current element and the position of the NGEle element. Stock Span Problem Brainstorm! #include <iostream> #include <vector> using namespace std ; vector < pair < int , int >> NGEle ( vector < int > vect ){ // Return a pair with NGEle and the position of the NGEle. vector < pair < int , int >> out ; // While storing the values into stack just add the current index to keep track // of where the NGEle is located. vector < pair < int , int >> stack ; // Common NGEle Code [it's the same lolzzzzz]. int index = 0 ; for ( int element : vect ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ element , index }); } else { while (( stack . size () != 0 ) && ( stack . back (). first < element )){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , index }); stack . push_back ({ element , index }); } else if ( stack . back (). first > element ){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ element , index }); } } index ++ ; } return out ; } vector < int > stockSpan ( vector < int > marketCap ){ // find NGEle Values for each day along with their indexes. vector < pair < int , int >> ngele = NGEle ( marketCap ); vector < int > out ; int idx = 0 ; // Now for each element find the distance between it and it's NGEle. for ( auto i : ngele ){ if ( i . second != -1 ){ out . push_back ( idx - i . second + 1 ); } else { out . push_back ( 1 ); } idx ++ ; } return out ; } Let's test the code out. Run the following code to see the code working. int main (){ vector < int > v = { 100 , 70 , 85 , 59 , 15 , 60 , 87 }; vector < pair < int , int >> ngele = NGEle ( v ); vector < int > stkspan = stockSpan ( v ); cout << \"Market CAP\" << endl ; for ( auto j : v ) cout << j << \" \" ; cout << endl ; cout << endl ; // ngele Array for ( auto i : ngele ){ cout << i . first << \" from: \" << i . second << \" \\n \" ; } cout << endl ; cout << \"Stock Span\" << endl ; for ( auto h : stkspan ) cout << h << \" \" ; cout << endl ; return 0 ; }","title":"Approach"},{"location":"stacks/problems/#time-complexity_1","text":"At the very worst case time complexity is \\(O(\\mathcal{N})\\) because we are traversing the marketCap vector only once during the subroutine NGEle() and once in the subroutine stockSpan() .","title":"Time Complexity"},{"location":"stacks/problems/#space-complexity_1","text":"Space complexity is \\(O(\\mathcal{N})\\) .","title":"Space Complexity"},{"location":"stacks/problems/#maximum-area-histogram","text":"","title":"Maximum Area Histogram"},{"location":"stacks/problems/#problem-statement_5","text":"Similar problem on Leetcode Given an array of integers heights representing the histogram's bar height where the width of each bar is \\(1\\) , return the area of the largest rectangle in the histogram.","title":"Problem Statement"},{"location":"stacks/problems/#examples_3","text":"Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units.","title":"Examples"},{"location":"stacks/problems/#thought-process","text":"Brainstorm!","title":"Thought process"},{"location":"stacks/problems/#approach_4","text":"Proper Approach!","title":"Approach"},{"location":"stacks/problems/#time-and-space-complexity","text":"\\(O(\\mathcal{N})\\) time and space is taken.","title":"Time and Space complexity"},{"location":"stacks/problems/#code","text":"","title":"Code"},{"location":"stacks/problems/#subroutines","text":"Two subroutines are needed \\(\\to\\) and these are NSEle and NSR. Neareast smaller to the left and neareast smaller to the right.","title":"Subroutines"},{"location":"stacks/problems/#nsr-nse-nearest-smaller-to-the-right-implementation","text":"#include <iostream> #include <vector> using std :: vector ; using std :: pair ; vector < pair < int , int >> NSE ( vector < int > vect ){ // Nearest smallest to the right // finds and returns NSE array pair.first -> value // pair.second -> index of the NSE element vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int last = vect . size () - 1 ; while ( last != -1 ){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ last ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ last ], last }); } else if ( stack . back (). first < vect [ last ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ last ], last }); } } last -- ; } return out ; }","title":"NSR (NSE, Nearest smaller to the Right) implementation"},{"location":"stacks/problems/#nsele-nearest-smaller-to-the-left-implementation","text":"vector < pair < int , int >> NSEle ( vector < int > vect ){ vector < pair < int , int >> out ; vector < pair < int , int >> stack ; int start = 0 ; while ( start != vect . size ()){ if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else { while (( stack . size () != 0 ) && ( stack . back (). first >= vect [ start ])){ stack . pop_back (); } if ( stack . size () == 0 ){ out . push_back ({ -1 , -1 }); stack . push_back ({ vect [ start ], start }); } else if ( stack . back (). first < vect [ start ]){ out . push_back ({ stack . back (). first , stack . back (). second }); stack . push_back ({ vect [ start ], start }); } } start ++ ; } return out ; }","title":"NSEle (Nearest smaller to the left) implementation"},{"location":"stacks/problems/#the-main-function-maxareahistogram","text":"void maxAreaHistogram ( vector < int > v ){ vector < int > out ; vector < pair < int , int >> nsr = NSE ( v ); // NSR has to-be reverse because we started from the begining std :: reverse ( nsr . begin (), nsr . end ()); vector < pair < int , int >> nsele = NSEle ( v ); int currentMax = -1 ; int index = 0 ; int currentArea = 0 ; for ( int i : v ){ if (( nsr [ index ]. first != -1 ) && ( nsele [ index ]. first != -1 )){ // Both upper and lower bound is within the array // Start from left bound + 1 // end at the upper bound - 1 (don't cosinder the upper bound bcz it's smaller) currentArea = i * (( nsr [ index ]. second - 1 ) - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsr [ index ]. first == -1 ) && ( nsele [ index ]. first != -1 )){ // right side -> -1 no smaller element to the right // Start from left bound + 1, (don't consider the left bound) // end at last currentArea = i * ( v . size () -1 - ( nsele [ index ]. second + 1 ) + 1 ); } else if (( nsele [ index ]. first == -1 ) && ( nsr [ index ]. first != -1 )){ // No bound to the left // So from index zero -> the upper bound currentArea = i * ( nsr [ index ]. second - 1 + 1 ); } else { // No bound at all -> size * magnitude currentArea = i * ( v . size ()); } out . push_back ( currentArea ); index ++ ; } for ( auto value : out ) std :: cout << BOLDBLUE << value << \" \" ; std :: cout << std :: endl ; }","title":"The main function maxAreaHistogram()"},{"location":"stacks/problems/#testing-the-code-out","text":"int main (){ // testsForNSE(); // testsForNSEle(); vector < int > v = { 1 , 2 , 3 , 1 , 2 , 3 , 4 , 5 , 5 , 5 }; std :: cout << BOLDCYAN << \"TEST CASE 1\" << RESET << std :: endl ; maxAreaHistogram ( v ); vector < int > v1 = { 2 , 1 , 5 , 6 , 2 , 3 }; std :: cout << BOLDYELLOW << \"TEST CASE 2\" << RESET << std :: endl ; maxAreaHistogram ( v1 ); vector < int > v2 = { 2 , 4 , 1 , 4 , 4 , 5 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2 ); vector < int > v12 = { 5 , 5 , 5 , 5 , 5 , 2 , 4 , 2 , 1 }; std :: cout << BOLDGREEN << \"TEST CASE 3\" << RESET << std :: endl ; maxAreaHistogram ( v12 ); vector < int > v23 = { 3 , 2 , 1 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v23 ); vector < int > v231 = { 10 , 9 , 8 , 7 }; std :: cout << BOLDRED << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v231 ); vector < int > v2321 = { 7 , 8 , 9 , 10 }; std :: cout << BOLDMAGENTA << \"TEST CASE 4\" << RESET << std :: endl ; maxAreaHistogram ( v2321 ); return 0 ; }","title":"Testing the code out"},{"location":"stacks/problems/#output","text":"TEST CASE 1 10 4 3 10 12 15 16 15 15 15 TEST CASE 2 2 6 10 6 8 3 TEST CASE 4 4 4 6 12 12 5 TEST CASE 3 25 25 25 25 25 16 4 16 9 TEST CASE 4 3 4 3 TEST CASE 4 10 18 24 28 TEST CASE 4 28 24 18 10","title":"Output"},{"location":"stacks/problems/#max-area-rectangle-under-binary-matrix","text":"Problem On leetcode \\(\\to\\)","title":"Max Area Rectangle under binary matrix"},{"location":"stacks/problems/#problem-statement_6","text":"Given a binary matrix \\(\\mathcal{M}\\) find out what is the maximum area of the rectangle \\(R\\) , where all elements in \\(R = 1\\) Explanation Input: matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]] Output: 6 Explanation: The maximal rectangle is shown in the above picture.","title":"Problem Statement"},{"location":"stacks/problems/#constraints_1","text":"rows == matrix.length cols == matrix[i].length 1 <= row, cols <= 200 matrix[i][j] is \\(0\\) or \\(1\\) .","title":"Constraints:"},{"location":"stacks/problems/#approach_5","text":"Proper Approach! We should start with creating histogram for each level. Then we call the MAH() algorithm implemented in the previous question. Then we find the maximum accross all levels.","title":"Approach"},{"location":"stacks/problems/#rain-water-trapping","text":"Same Problem on Leetcode \\(\\to\\)","title":"Rain water trapping"},{"location":"stacks/problems/#problem-statement_7","text":"Given \\(N\\) non-negative integers representing an elevation map where the width of each bar is \\(1\\) , compute how much water it can trap after raining.","title":"Problem Statement"},{"location":"stacks/problems/#example","text":"Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.","title":"Example"},{"location":"stacks/problems/#explainer","text":"Rain Water Trapping Explainer","title":"Explainer"},{"location":"stacks/problems/#approach_6","text":"For each building figure out how much water can be trapped on top of its roof. For all buildings add the water trapped on top of its roof. Return the total. To calculate how much water can be trapped on top of its roof, look left and see what is the largest building and look right and see what is the largest building. Get the smallest of those two. That should be the height of water on top of the building. Rain Water Trapping Approach Explainer","title":"Approach"},{"location":"stacks/problems/#solution","text":"For each building find the maximum height on both left and right sides [using heaps], then take the minimum of those heights \\(\\to\\) that should be the water height at that location. Subtract the height of the building from it to get how much water is stored on top of the building. For each building add up all the water stored on top of the roof. Return the sum as the total water stored in the system.","title":"Solution"},{"location":"stacks/problems/#the-skyline-problem","text":"Same Problem on Leetcode \\(\\to\\)","title":"The Skyline problem"},{"location":"stacks/problems/#problem-statement_8","text":"A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return the skyline formed by these buildings collectively.","title":"Problem Statement"},{"location":"stacks/usage/","text":"Implementation of Stacks and Queues A stack and Queue provides 2 basic operations, for stack it is push() and pop() and for queues it is enqueue() , dequeue() . Using Python's collection's deque we can implement both stack as well as queue in no time. In an interview setting you can implement stacks and queues from scratch in about 30-40 lines of code, for that I'll recommend you to use the following implementations. Stacks from Scratch Queue from Scratch In interview setting I highly recommend you to use the collections.dequeue to implement the stack and queue classes. Source Code from collections import deque from rich.console import Console console = Console () # For printing purposes class QueueWithDequeue : def __init__ ( self , iterable = None ): if not iterable : self . queue = deque () else : self . queue = deque ( iterable ) def dequeue ( self ): # Automatically will raise Error if the queue is empty return self . queue . popleft () def enqueue ( self , value ): self . queue . append ( value ) def show ( self ): console . print ([ data for data in self . queue ]) Stacks implementation with Deque Module class Stack : def __init__ ( self , iterable = None ): if not iterable : self . container = deque () else : self . container = deque ( iterable ) def pop ( self ): return self . container . pop () def push ( self , val ): return self . container . append ( val ) def tos ( self ): # Get the top of the stack return self . container [ - 1 ] def __repr__ ( self ): return f \" { [ data for data in self . container ] } \" Stacks implementation with C++ With C++ STL stack implementation is really easy with vector. Here is a simple example of implementation of MinStack that stores elemenents as well as return min value in \\(O(1)\\) time. #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } };","title":"Stacks Usage"},{"location":"stacks/usage/#implementation-of-stacks-and-queues","text":"A stack and Queue provides 2 basic operations, for stack it is push() and pop() and for queues it is enqueue() , dequeue() . Using Python's collection's deque we can implement both stack as well as queue in no time. In an interview setting you can implement stacks and queues from scratch in about 30-40 lines of code, for that I'll recommend you to use the following implementations. Stacks from Scratch Queue from Scratch In interview setting I highly recommend you to use the collections.dequeue to implement the stack and queue classes.","title":"Implementation of Stacks and Queues"},{"location":"stacks/usage/#source-code","text":"from collections import deque from rich.console import Console console = Console () # For printing purposes class QueueWithDequeue : def __init__ ( self , iterable = None ): if not iterable : self . queue = deque () else : self . queue = deque ( iterable ) def dequeue ( self ): # Automatically will raise Error if the queue is empty return self . queue . popleft () def enqueue ( self , value ): self . queue . append ( value ) def show ( self ): console . print ([ data for data in self . queue ])","title":"Source Code"},{"location":"stacks/usage/#stacks-implementation-with-deque-module","text":"class Stack : def __init__ ( self , iterable = None ): if not iterable : self . container = deque () else : self . container = deque ( iterable ) def pop ( self ): return self . container . pop () def push ( self , val ): return self . container . append ( val ) def tos ( self ): # Get the top of the stack return self . container [ - 1 ] def __repr__ ( self ): return f \" { [ data for data in self . container ] } \"","title":"Stacks implementation with Deque Module"},{"location":"stacks/usage/#stacks-implementation-with-c","text":"With C++ STL stack implementation is really easy with vector. Here is a simple example of implementation of MinStack that stores elemenents as well as return min value in \\(O(1)\\) time. #include <iostream> #include <vector> using namespace std ; class MinStack { private : vector < int > stack ; vector < int > auxStack ; int ClassPrivateSize ; public : MinStack (){ ClassPrivateSize = 0 ; } int size (){ return ClassPrivateSize ; } void push ( int value ){ if ( ClassPrivateSize == 0 ){ stack . push_back ( value ); auxStack . push_back ( value ); ClassPrivateSize += 1 ; } else { if ( value < auxStack . back ()){ stack . push_back ( value ); auxStack . push_back ( value ); } else { stack . push_back ( value ); } ClassPrivateSize += 1 ; } } int pop (){ if ( ClassPrivateSize == 0 ){ throw runtime_error ( \"pop(): Empty Stack\" ); } else { if ( auxStack . back () == stack . back ()){ int value = stack . back (); auxStack . pop_back (); stack . pop_back (); return value ; } else { int value = stack . back (); stack . pop_back (); return value ; } ClassPrivateSize -= 1 ; } } bool isEmpty () const { if ( ClassPrivateSize == 0 ){ return true ; } return false ; } int min (){ return auxStack . back (); } int peek () { return stack . back (); } };","title":"Stacks implementation with C++"}]}